{
	"info": {
		"_postman_id": "a55f8089-550d-4db3-a25f-cf628894be15",
		"name": "DeDi API Collection",
		"description": "Complete DeDi API collection with dual authentication support (Cookie + API Key). Updated for latest backend version with password authentication, delegate management, CSV export, and enhanced bulk upload features.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "27224718"
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// üîê DeDi API Collection - Dual Authentication Handler",
					"// This script automatically handles both Cookie and API Key authentication",
					"",
					"const apiKey = pm.collectionVariables.get('api_key');",
					"const authCookie = pm.collectionVariables.get('auth_cookie');",
					"",
					"// Priority: API Key > Cookie",
					"if (apiKey && apiKey !== '' && !apiKey.includes('paste-your-api-key')) {",
					"  // Use API Key authentication (recommended for production)",
					"  pm.request.headers.upsert({",
					"    key: 'Authorization',",
					"    value: `Bearer ${apiKey}`",
					"  });",
					"  // Remove cookie header if present",
					"  pm.request.headers.remove('Cookie');",
					"} else if (authCookie && authCookie !== '' && !authCookie.includes('paste-your-token')) {",
					"  // Use Cookie authentication (for browser integration)",
					"  pm.request.headers.upsert({",
					"    key: 'Cookie',",
					"    value: `token=${authCookie}`",
					"  });",
					"  // Remove Authorization header if present",
					"  pm.request.headers.remove('Authorization');",
					"} else {",
					"  // No authentication configured - endpoints may fail if auth is required",
					"  pm.request.headers.remove('Authorization');",
					"  pm.request.headers.remove('Cookie');",
					"}"
				]
			}
		}
	],
	"item": [
		{
			"name": "Setup",
			"item": [
				{
					"name": "üîß Authentication Setup Helper",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// DeDi API Authentication Setup Helper",
									"console.log('ÔøΩ DEDI AUTHENTICATION SETUP');",
									"console.log('=========================================');",
									"console.log('');",
									"console.log('üéØ DeDi supports TWO authentication methods:');",
									"console.log('');",
									"console.log('üìå METHOD 1: API KEY (Recommended for Production)');",
									"console.log('1. ‚úâÔ∏è  Register using the \"register/login\" endpoint');",
									"console.log('2. üìß Verify your email by clicking the magic link');",
									"console.log('3. üîë Use \"get-api-key\" endpoint to generate your API key');",
									"console.log('4. üîß Set \"api_key\" collection variable with the generated key');",
									"console.log('5. ‚úÖ All authenticated requests will use Bearer token automatically!');",
									"console.log('');",
									"console.log('üìå METHOD 2: COOKIE AUTHENTICATION (Browser Integration)');",
									"console.log('1. ‚úâÔ∏è  Register and verify email (same as Method 1)');",
									"console.log('2. üåê Open browser DevTools (F12) after email verification');",
									"console.log('3. üç™ Go to: Application ‚Üí Cookies ‚Üí Copy \"token\" cookie value');",
									"console.log('4. üîß Set \"auth_cookie\" collection variable with cookie value');",
									"console.log('5. ‚úÖ Requests will use cookie authentication automatically!');",
									"console.log('');",
									"console.log('üí° PRODUCTION TIP: Use API Key method for server-to-server integration');",
									"console.log('üí° DEVELOPMENT TIP: Use Cookie method for browser-based testing');",
									"console.log('');",
									"",
									"// Check authentication status",
									"const apiKey = pm.collectionVariables.get('api_key');",
									"const authCookie = pm.collectionVariables.get('auth_cookie');",
									"",
									"if (apiKey && apiKey !== '' && !apiKey.includes('paste-your-api-key')) {",
									"  console.log('‚úÖ API Key Authentication: CONFIGURED');",
									"  console.log('üéâ Ready for production integration!');",
									"} else if (authCookie && authCookie !== '' && !authCookie.includes('paste-your-token')) {",
									"  console.log('‚úÖ Cookie Authentication: CONFIGURED');",
									"  console.log('üéâ Ready for development testing!');",
									"} else {",
									"  console.log('‚ùå Authentication: NOT CONFIGURED');",
									"  console.log('üîß Action: Choose and configure one of the methods above');",
									"}",
									"",
									"console.log('');",
									"console.log('üìö API Documentation: https://docs.dedi.global');"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// Validate API health check response",
									"pm.test('API Health Check', function() {",
									"  pm.expect(pm.response.code).to.equal(200);",
									"  const res = pm.response.json();",
									"  pm.expect(res).to.have.property('isConnected');",
									"  pm.expect(res.isConnected).to.be.true;",
									"});",
									"",
									"console.log('');",
									"console.log('üéØ NEXT STEPS:');",
									"console.log('- If auth is not configured: Follow the setup steps above');",
									"console.log('- If auth is configured: You can now use any authenticated endpoint!');",
									"console.log('- Start with \"getCurrentUser\" to test your authentication');"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi",
							"host": [
								"{{url}}"
							],
							"path": [
								"dedi"
							]
						},
						"description": "üîß AUTHENTICATION SETUP HELPER\n\nThis endpoint helps you set up authentication for the entire collection.\n\n**IMPORTANT:** After running this, check the Console tab for detailed setup instructions.\n\n**Quick Setup:**\n1. Register using the 'register/login' endpoint\n2. Click email verification link\n3. Copy 'token' cookie from browser DevTools\n4. Set it as 'auth_cookie' in Collection Variables\n5. All authenticated endpoints will work automatically!\n\n**This endpoint calls the health check API to verify your connection.**"
					},
					"response": []
				}
			]
		},
		{
			"name": "Authentication",
			"item": [
				{
					"name": "register/login",
			"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"if (!pm.variables.get(\"user_email\")) {",
						"  pm.variables.set(\"user_email\", \"testuser@yourdomain.com\");",
						"}",
						"if (!pm.variables.get(\"user_name\")) {",
						"  pm.variables.set(\"user_name\", \"TestUser\");",
						"}",
						"if (!pm.variables.get(\"user_action\")) {",
						"  pm.variables.set(\"user_action\", \"register\");",
						"}",
						"if (!pm.variables.get(\"user_password\")) {",
						"  pm.variables.set(\"user_password\", \"Test@123\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 201, 400, 401, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 401, 500]);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"email\": \"{{user_email}}\",\n  \"name\": \"{{user_name}}\",\n  \"action\": \"{{user_action}}\",\n  \"password\": \"{{user_password}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/register",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"register"
					]
					},
					"description": "üìù REGISTER/LOGIN\n\n**Registration & Login:** Use 'action' as 'register' or 'login'\n\n**Request Body:**\n- `email`: Valid email address (required)\n- `name`: Display name (required for registration, optional for login)\n- `action`: 'register' or 'login' (required)\n- `password`: Password with at least 6 characters and one special character (required)\n\n**Password Requirements:**\n- Minimum 6 characters\n- Must include at least one special character (@$!%*?&)\n\n**Registration Flow:**\n1. Call this endpoint with action='register'\n2. Check email for verification link\n3. Click verification link to activate account\n4. Use 'get-current-user' or 'get-api-key' for authentication\n\n**Login Flow:**\n1. Call this endpoint with action='login' (name optional)\n2. Account must already be registered and verified\n3. Use returned authentication for API access"
				},
				"response": []
			},
		{
			"name": "verify-email",
			"event": [
				{
				"listen": "prerequest",
				"script": {
					"type": "text/javascript",
					"exec": [
					"// Set a dummy token for testing if not present",
					"if (!pm.variables.get(\"email_verification_token\")) {",
					"  pm.variables.set(\"email_verification_token\", \"<paste-a-valid-token-here>\");",
					"}"
					]
				}
				},
				{
				"listen": "test",
				"script": {
					"type": "text/javascript",
					"exec": [
					"pm.test(\"Status code is 200, 400, or 404\", function () {",
					"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 404]);",
					"});",
					"pm.test(\"Response has status or error\", function () {",
					"  const res = pm.response.json();",
					"  if (pm.response.code === 200) {",
					"    pm.expect(res).to.have.property(\"status\");",
					"    if (res.status === \"success\" && res.data) {",
					"      pm.expect(res).to.have.property(\"data\");",
					"      // Auto-save refresh token if present",
					"      if (res.data.refresh_token) {",
					"        pm.collectionVariables.set(\"refresh_token\", res.data.refresh_token);",
					"        console.log('‚úÖ Refresh token saved to collection variables');",
					"      }",
					"    }",
					"  } else {",
					"    pm.expect(res).to.have.property(\"error\");",
					"  }",
					"});"
					]
				}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
				"raw": "{{url}}/dedi/verify-email?token={{email_verification_token}}",
				"host": [
					"{{url}}"
				],
				"path": [
					"dedi",
					"verify-email"
				],
				"query": [
					{
					"key": "token",
					"value": "{{email_verification_token}}"
					}
				]
				},
				"description": "Verifies the email using the magic link token. Set 'email_verification_token' variable after registration."
			},
				"response": []
			},
			{
				"name": "get-current-user",
			"event": [
				{
				"listen": "prerequest",
				"script": {
					"type": "text/javascript",
					"exec": [
					"// ‚úÖ Authentication is handled automatically by the global collection script",
					"// This endpoint requires authentication - the global script will apply the cookie",
					"",
					"// One-time setup helper: Check if auth cookie is configured",
					"const authCookie = pm.collectionVariables.get('auth_cookie');",
					"if (!authCookie || authCookie === '' || authCookie === '<paste-your-token-cookie-here>') {",
					"  console.warn('üîß SETUP REQUIRED: Configure auth_cookie in Collection Variables');",
					"  console.warn('üìã Steps: Register ‚Üí Email Verification ‚Üí Copy token cookie ‚Üí Set Collection Variable');",
					"}"
					]
				}
				},
				{
				"listen": "test",
				"script": {
					"type": "text/javascript",
					"exec": [
					"pm.test(\"Status code is 200, 401, 404, or 500\", function () {",
					"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 404, 500]);",
					"});",
					"pm.test(\"Response has user details or error message\", function () {",
					"  const res = pm.response.json();",
					"  if (pm.response.code === 200) {",
					"    // Basic user details that are always present",
					"    pm.expect(res).to.have.property(\"id\");",
					"    pm.expect(res).to.have.property(\"email\");",
					"    pm.expect(res).to.have.property(\"email_verified\");",
					"    pm.expect(res).to.have.property(\"profile_id\");",
					"    // access_token is only present with cookie authentication, not API key",
					"    // pm.expect(res).to.have.property(\"access_token\"); // Optional",
					"  } else {",
					"    pm.expect(res).to.have.property(\"message\");",
					"  }",
					"});"
					]
				}
				}
			],
			"request": {
				"auth": {
				"type": "noauth"
				},
				"method": "GET",
				"header": [],
				"url": {
				"raw": "{{url}}/dedi/auth/me",
				"host": [
					"{{url}}"
				],
				"path": [
					"dedi",
					"auth",
					"me"
				]
				},
				"description": "Fetches the current authenticated user's details. Requires authentication via cookie. After login/verification, copy the 'token' cookie from your browser and paste it into the 'auth_cookie' variable in Postman. This endpoint returns user details if authenticated, or an error message if not."
			},
				"response": []
			},
			{
			"name": "refresh-token",
			"event": [
				{
				"listen": "prerequest",
				"script": {
					"type": "text/javascript",
					"exec": [
					"// ‚úÖ Authentication is handled automatically by the collection script",
					"// Ensure refresh_token is set for testing",
					"if (!pm.collectionVariables.get(\"refresh_token\")) {",
					"  pm.collectionVariables.set(\"refresh_token\", \"<paste-your-refresh-token-here>\");",
					"}"
					]
				}
				},
				{
				"listen": "test",
				"script": {
					"type": "text/javascript",
					"exec": [
					"pm.test(\"Status code is 200, 401, or 500\", function () {",
					"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 500]);",
					"});",
					"pm.test(\"Response has message or data\", function () {",
					"  const res = pm.response.json();",
					"  pm.expect(res).to.have.property(\"message\");",
					"  if (pm.response.code === 200 && res.data) {",
					"    // Auto-save new refresh token if present",
					"    if (res.data.refresh_token) {",
					"      pm.collectionVariables.set(\"refresh_token\", res.data.refresh_token);",
					"      console.log('‚úÖ New refresh token saved to collection variables');",
					"    }",
					"    // Auto-save new access token if present",
					"    if (res.data.access_token) {",
					"      console.log('‚úÖ New access token available in response');",
					"    }",
					"  }",
					"});"
					]
				}
				}
			],
			"request": {
				"auth": {
				"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
				"mode": "raw",
				"raw": "{\n    \"refresh_token\": \"{{refresh_token}}\"\n}",
				"options": {
					"raw": {
					"language": "json"
					}
				}
				},
				"url": {
				"raw": "{{url}}/dedi/token/refresh",
				"host": [
					"{{url}}"
				],
				"path": [
					"dedi",
					"token",
					"refresh"
				]
				},
				"description": "üîÑ REFRESH ACCESS TOKEN\n\nRefreshes an expired access token using a valid refresh token.\n\n**Authentication:** Required (existing valid session)\n\n**Request Body:**\n- `refresh_token`: Valid refresh token obtained during login\n\n**Response:**\n- New access token and refresh token pair\n- Updated session information\n\n**Use Cases:**\n- Maintaining session without re-authentication\n- Automatic token renewal in applications\n- Session management in long-running processes"
			},
				"response": []
			},
			{
			"name": "logout",
			"event": [
				{
				"listen": "prerequest",
				"script": {
					"type": "text/javascript",
					"exec": [
					"// ‚úÖ Authentication is handled automatically by the global collection script"
					]
				}
				},
				{
				"listen": "test",
				"script": {
					"type": "text/javascript",
					"exec": [
					"pm.test(\"Status code is 200, 401, or 500\", function () {",
					"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 500]);",
					"});",
					"pm.test(\"Response has message\", function () {",
					"  pm.expect(pm.response.json()).to.have.property(\"message\");",
					"});"
					]
				}
				}
			],
			"request": {
				"auth": {
				"type": "noauth"
				},
				"method": "POST",
				"header": [],
				"body": {
				"mode": "raw",
				"raw": "",
				"options": {
					"raw": {
					"language": "json"
					}
				}
				},
				"url": {
				"raw": "{{url}}/dedi/logout",
				"host": [
					"{{url}}"
				],
				"path": [
					"dedi",
					"logout"
				]
				},
				"description": "Requires authentication via cookie. After login/verification, copy the 'token' cookie from your browser and paste it into the 'auth_cookie' variable in Postman. This endpoint logs out the user and clears the authentication cookie."
			},
			"response": []
			},
			{
				"name": "get-api-key",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// ‚úÖ Authentication is handled automatically by the global collection script",
								"// This endpoint requires authentication - use either cookie or existing API key",
								""
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 200, 401, 404, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 404, 500]);",
								"});",
								"pm.test(\"Response has API key or error message\", function () {",
								"  const res = pm.response.json();",
								"  if (pm.response.code === 200) {",
								"    pm.expect(res).to.have.property(\"api_key\");",
								"    // Auto-set the API key for future requests",
								"    pm.collectionVariables.set(\"api_key\", res.api_key);",
								"    console.log('‚úÖ API Key generated and saved to collection variables!');",
								"    console.log('üéâ You can now use API key authentication for all requests!');",
								"  } else {",
								"    pm.expect(res).to.have.property(\"message\");",
								"  }",
								"});"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
						"raw": "{{url}}/dedi/get-api-key",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"get-api-key"
						]
					},
					"description": "üîë GENERATE API KEY\n\nGenerates an API key for programmatic access to DeDi APIs. This is the recommended authentication method for production integrations.\n\n**Prerequisites:**\n- User must be registered and email verified\n- Must be authenticated (cookie or existing API key)\n\n**Response:**\n- Returns `access_token` that can be used as Bearer token\n- API key is automatically saved to collection variables\n\n**Usage:**\n- Set the returned `access_token` as `api_key` collection variable\n- All subsequent requests will use Bearer token authentication\n- No need to manage cookies or browser sessions"
				},
				"response": []
			},
			{
				"name": "reset-password",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// ‚úÖ Authentication is handled automatically by the global collection script",
								"// This endpoint requires authentication"
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 200, 401, 404, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 404, 500]);",
								"});",
								"pm.test(\"Response has message\", function () {",
								"  pm.expect(pm.response.json()).to.have.property(\"message\");",
								"});"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
						"mode": "raw",
						"raw": "{\n  \"new_password\": \"{{new_password}}\",\n  \"confirm_password\": \"{{confirm_password}}\"\n}",
						"options": {
							"raw": {
								"language": "json"
							}
						}
					},
					"url": {
						"raw": "{{url}}/dedi/reset-password",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"reset-password"
						]
					},
					"description": "üîÑ RESET PASSWORD (AUTHENTICATED USER)\n\nReset password for the currently authenticated user.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n- `old_password`: Current password (required)\n- `new_password`: New password meeting requirements (required)\n\n**Password Requirements:**\n- Minimum 6 characters\n- Must include at least one special character (@$!%*?&)\n\n**Use Cases:**\n- User wants to change their password while logged in\n- Security updates for authenticated users"
				},
				"response": []
			},
			{
				"name": "forgot-password",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// No authentication required for this endpoint",
								"if (!pm.variables.get(\"user_email\")) {",
								"  pm.variables.set(\"user_email\", \"testuser@yourdomain.com\");",
								"}"
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 201, 400, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 500]);",
								"});",
								"pm.test(\"Response has message\", function () {",
								"  pm.expect(pm.response.json()).to.have.property(\"message\");",
								"});"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
						"mode": "raw",
						"raw": "{\n  \"email\": \"{{user_email}}\"\n}",
						"options": {
							"raw": {
								"language": "json"
							}
						}
					},
					"url": {
						"raw": "{{url}}/dedi/forgot-password",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"forgot-password"
						]
					},
					"description": "üîí FORGOT PASSWORD\n\nSend a password reset link to the user's email address.\n\n**Authentication:** None required\n\n**Request Body:**\n- `email`: Email address of the account (required)\n\n**Process:**\n1. Submit email address\n2. Check email for reset link\n3. Use reset link to access password reset form\n4. Set new password via reset-password/confirm endpoint\n\n**Use Cases:**\n- User forgot their password\n- Account recovery without current password"
				},
				"response": []
			},
			{
				"name": "reset-password/confirm",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// No authentication required - uses reset token",
								"if (!pm.variables.get(\"reset_token\")) {",
								"  pm.variables.set(\"reset_token\", \"<paste-reset-token-from-email>\");",
								"}",
								"if (!pm.variables.get(\"new_password\")) {",
								"  pm.variables.set(\"new_password\", \"NewPass@123\");",
								"}"
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 200, 400, 401, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 500]);",
								"});",
								"pm.test(\"Response has message\", function () {",
								"  pm.expect(pm.response.json()).to.have.property(\"message\");",
								"});"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
						"mode": "raw",
						"raw": "{\n  \"token\": \"{{reset_token}}\",\n  \"new_password\": \"{{new_password}}\"\n}",
						"options": {
							"raw": {
								"language": "json"
							}
						}
					},
					"url": {
						"raw": "{{url}}/dedi/reset-password/confirm",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"reset-password",
							"confirm"
						]
					},
					"description": "‚úÖ CONFIRM PASSWORD RESET\n\nConfirm password reset using the token received via email.\n\n**Authentication:** None required (uses reset token)\n\n**Request Body:**\n- `token`: Reset token from email link (required)\n- `new_password`: New password meeting requirements (required)\n\n**Password Requirements:**\n- Minimum 6 characters\n- Must include at least one special character (@$!%*?&)\n\n**Process:**\n1. User receives reset email from forgot-password endpoint\n2. Extract token from email link\n3. Submit token with new password\n4. Password is updated and user can login with new credentials\n\n**Security:** Reset tokens expire after 15 minutes by default"
				},
				"response": []
			},
			{
				"name": "resend-magic-link",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// No authentication required",
								"if (!pm.variables.get(\"user_email\")) {",
								"  pm.variables.set(\"user_email\", \"testuser@yourdomain.com\");",
								"}",
								"if (!pm.variables.get(\"user_name\")) {",
								"  pm.variables.set(\"user_name\", \"TestUser\");",
								"}",
								"if (!pm.variables.get(\"user_password\")) {",
								"  pm.variables.set(\"user_password\", \"Test@123\");",
								"}"
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 201, 400, 401, 404, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 401, 404, 500]);",
								"});",
								"pm.test(\"Response has message\", function () {",
								"  pm.expect(pm.response.json()).to.have.property(\"message\");",
								"});"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
						"mode": "raw",
						"raw": "{\n  \"action\": \"register\",\n  \"email\": \"{{user_email}}\",\n  \"name\": \"{{user_name}}\",\n  \"password\": \"{{user_password}}\"\n}",
						"options": {
							"raw": {
								"language": "json"
							}
						}
					},
					"url": {
						"raw": "{{url}}/dedi/resend-magic-link",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"resend-magic-link"
						]
					},
					"description": "üì¨ RESEND MAGIC LINK\n\nResend email verification link for users who didn't receive or lost their verification email.\n\n**Authentication:** None required\n\n**Request Body:**\n- `action`: Should be 'register' (required)\n- `email`: Email address of the account (required)\n- `name`: User's name (required)\n- `password`: User's password (required)\n\n**Prerequisites:**\n- User must already be registered\n- Account must exist in the system\n\n**Use Cases:**\n- User didn't receive verification email\n- Verification email expired\n- User deleted verification email accidentally\n\n**Note:** This endpoint requires the user's existing credentials to prevent abuse"
				},
				"response": []
			}
			]
		},
		{
			"name": "publish",
			"item": [
				{
				"name": "create namespace",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"// Generate unique namespace name and description for testing",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueName = generateUniqueString(\"name\");",
						"const uniqueDesc = generateUniqueString(\"desc\");",
						"pm.variables.set(\"namespace_name\", uniqueName);",
						"pm.variables.set(\"namespace_desc\", uniqueDesc);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 201, 400, 401, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 401, 404, 500]);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});",
						"if (pm.response.code === 201) {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"data\");",
						"  pm.expect(response.data).to.have.property(\"namespace_id\");",
						"  pm.collectionVariables.set(\"namespace\", response.data.namespace_id);",
						"  console.log('‚úÖ Namespace created:', response.data.namespace_id);",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"name\": \"{{namespace_name}}\",\n  \"description\": \"{{namespace_desc}}\",\n  \"meta\": {}\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/create-namespace",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"create-namespace"
					]
					},
					"description": "üìÅ CREATE NAMESPACE\n\nCreates a new namespace to organize and group related registries.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n- `name`: Unique namespace name (string, required)\n- `description`: Description of the namespace purpose (string, required)\n- `meta`: Additional metadata (object, optional)\n- `version_count`: Version number (number, optional)\n\n**Response:**\n- Namespace details including `namespace_id`, `digest`, and creation info\n- The `namespace_id` can be used in subsequent registry and record operations\n\n**Use Cases:**\n- Organizing data by department/project\n- Creating isolated environments\n- Setting up customer-specific data spaces\n- Domain-based data segregation\n\n**Rate Limits:** Standard API rate limits apply"
				},
				"response": []
			},
			{
				"name": "create registry",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"// Generate unique registry name for testing",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueName = generateUniqueString(\"registry\");",
						"pm.variables.set(\"registry_name\", uniqueName);",
						"pm.variables.set(\"registry_description\", `Description for ${uniqueName}`);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 201, 400, 401, 403, 404, 409, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 401, 403, 404, 409, 500]);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});",
						"if (pm.response.code === 201) {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"data\");",
						"  pm.expect(response.data).to.have.property(\"registry_id\");",
						"  pm.collectionVariables.set(\"registry_id\", response.data.registry_id);",
						"  pm.collectionVariables.set(\"registry_name\", pm.variables.get(\"registry_name\"));",
						"  console.log('‚úÖ Registry created:', response.data.registry_id);",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"registry_name\": \"{{registry_name}}\",\n  \"description\": \"{{registry_description}}\",\n  \"schema\": {\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"description\": \"Custom registry schema for {{registry_name}}\",\n    \"type\": \"object\",\n    \"properties\": {\n      \"name\": {\n        \"type\": \"string\",\n        \"description\": \"Name of the entity\"\n      },\n      \"description\": {\n        \"type\": \"string\",\n        \"description\": \"Description of the entity\"\n      }\n    },\n    \"required\": [\"name\"]\n  },\n  \"tag\": \"custom\",\n  \"meta\": {\n    \"created_by\": \"api\",\n    \"purpose\": \"Production registry\"\n  }\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/create-registry",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"create-registry"
					]
					},
					"description": "üìã CREATE REGISTRY\n\nCreates a new registry within a namespace to store structured records.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: The namespace ID or domain where the registry will be created\n\n**Request Body:**\n- `registry_name`: Unique name for the registry\n- `description`: Description of what this registry stores\n- `schema`: JSON Schema defining the structure of records\n- `tag`: Schema tag ('custom', 'membership', 'public_key', 'revoke')\n- `meta`: Additional metadata (optional)\n\n**Response:**\n- Registry details including `registry_id`, `digest`, and metadata\n\n**Use Cases:**\n- Setting up data collection schemas\n- Creating structured data repositories\n- Defining verification templates"
				},
				"response": []
			},
			{
				"name": "save record as draft",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"// Generate unique record name/desc for testing",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueName = generateUniqueString(\"rec_name\");",
						"const uniqueDesc = generateUniqueString(\"rec_desc\");",
						"pm.variables.set(\"rec_name\", uniqueName);",
						"pm.variables.set(\"rec_desc\", uniqueDesc);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 201, 400, 401, 403, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 401, 403, 404, 500]);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});",
						"if (pm.response.code === 201) {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"data\");",
						"  pm.collectionVariables.set(\"record_name\", pm.variables.get(\"rec_name\"));",
						"  if (response.data.record_id) {",
						"    pm.collectionVariables.set(\"record_id\", response.data.record_id);",
						"  }",
						"  console.log('‚úÖ Record draft created:', pm.variables.get(\"rec_name\"));",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"record_name\": \"{{rec_name}}\",\n  \"description\": \"{{rec_desc}}\",\n  \"details\": {\n    \"name\": \"Sample Entity Name\",\n    \"description\": \"Sample entity for testing\"\n  },\n  \"meta\": {\n    \"// This field is for your application using DeDi - add any metadata you need\": \"\",\n    \"application_id\": \"your-app-identifier\",\n    \"created_by\": \"api-user\",\n    \"environment\": \"production\"\n  },\n  \"valid_till\": \"2025-12-31T23:59:59Z\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/save-record-as-draft?publish=false",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"{{registry_name}}",
						"save-record-as-draft"
					],
					"query": [
						{
							"key": "publish",
							"value": "false",
							"description": "Set to 'true' to save and publish immediately"
						}
					]
					},
					"description": "üíæ SAVE RECORD AS DRAFT\n\nCreates a new record in draft state within a registry. Draft records can be modified before publishing.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Target registry name\n\n**Query Parameters:**\n- `publish`: Set to 'true' to save and publish immediately (optional)\n\n**Request Body:**\n- `record_name`: Unique record name (string, required)\n- `description`: Record description (string, required)\n- `details`: Record data matching registry schema (object, required)\n- `meta`: Application metadata (object, optional)\n- `valid_till`: Expiration date in ISO format (string, optional)\n\n**Response:**\n- Record details including `record_id` and draft status\n\n**Use Cases:**\n- Creating records that need review before publishing\n- Batch record preparation\n- Multi-step record creation workflows"
				},
				"response": []
			},
			{
				"name": "publish record",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"// Verify required variables are set",
						"const requiredVars = ['namespace', 'registry_name', 'record_name'];",
						"const missing = requiredVars.filter(v => !pm.collectionVariables.get(v));",
						"if (missing.length > 0) {",
						"  console.warn('‚ö†Ô∏è Missing required variables:', missing.join(', '));",
						"  console.warn('üìã Run create-namespace, create-registry, and save-record-as-draft first');",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200, 400, 401, 403, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403, 404, 500]);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});",
						"if (pm.response.code === 200) {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"data\");",
						"  if (response.data.record_id) {",
						"    pm.collectionVariables.set(\"record_id\", response.data.record_id);",
						"    console.log('‚úÖ Record published:', response.data.record_id);",
						"  }",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"description\": \"Updated description for published record\",\n  \"meta\": {\n    \"published_by\": \"api-user\",\n    \"environment\": \"production\",\n    \"publish_reason\": \"Record ready for production use\"\n  }\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/publish-record",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"{{registry_name}}",
						"{{record_name}}",
						"publish-record"
					]
					},
					"description": "üì§ PUBLISH RECORD\n\nPublishes a record from draft state to live state, making it available for queries and verification.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Name of the record to publish\n\n**Prerequisites:**\n- Record must exist in 'draft' state\n- User must have authorization to the registry\n- Registry must be active (not revoked/archived)\n\n**Response:**\n- Confirmation message with `record_id`\n- Record state changes from 'draft' to 'live'\n\n**Use Cases:**\n- Making draft records publicly available\n- Finalizing record creation workflow\n- Triggering registry watchers and notifications\n\n**Important:** Once published, records cannot be unpublished, only updated or revoked."
				},
				"response": []
			},
			{
				"name": "export-records-as-csv",
				"event": [
					{
						"listen": "prerequest",
						"script": {
							"type": "text/javascript",
							"exec": [
								"// ‚úÖ Authentication is handled automatically by the global collection script",
								"// Verify required variables are set",
								"const requiredVars = ['namespace', 'registry_name'];",
								"const missing = requiredVars.filter(v => !pm.collectionVariables.get(v));",
								"if (missing.length > 0) {",
								"  console.warn('‚ö†Ô∏è Missing required variables:', missing.join(', '));",
								"  console.warn('üìã Run create-namespace and create-registry first');",
								"}"
							]
						}
					},
					{
						"listen": "test",
						"script": {
							"type": "text/javascript",
							"exec": [
								"pm.test(\"Status code is 200, 400, 401, 403, 404, or 500\", function () {",
								"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403, 404, 500]);",
								"});",
								"// Check if response is CSV data",
								"if (pm.response.code === 200) {",
								"  pm.test(\"Response is CSV format\", function () {",
								"    const contentType = pm.response.headers.get('Content-Type');",
								"    pm.expect(contentType).to.include('text/csv');",
								"  });",
								"  console.log('‚úÖ CSV export successful');",
								"} else {",
								"  pm.test(\"Response has error message\", function () {",
								"    const res = pm.response.json();",
								"    pm.expect(res).to.have.property(\"message\");",
								"  });",
								"}"
							]
						}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
						"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/export-as-csv",
						"host": [
							"{{url}}"
						],
						"path": [
							"dedi",
							"{{namespace}}",
							"{{registry_name}}",
							"export-as-csv"
						]
					},
					"description": "üìä EXPORT RECORDS AS CSV\n\nExport all records from a registry as a CSV file for analysis, backup, or migration purposes.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to export records from\n\n**Response:**\n- CSV file with all records from the registry\n- Content-Type: text/csv\n- File download with registry data\n\n**CSV Format:**\n- Headers match registry schema fields\n- One row per record\n- Includes record metadata (ID, timestamps, state)\n- Nested objects flattened with dot notation\n\n**Use Cases:**\n- Data backup and archival\n- Analytics and reporting\n- Data migration to other systems\n- Compliance and audit requirements\n- Integration with external tools\n\n**Performance:**\n- Optimized for large datasets\n- Streaming response for memory efficiency\n- Suitable for registries with thousands of records\n\n**Access Control:**\n- Requires registry read permissions\n- User must be authorized for the registry\n- Respects data privacy settings"
				},
				"response": []
			},
			{
				"name": "bulk-upload",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200, 400, 401, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 404, 500]);",
						"});",
						"pm.test(\"Response has status and message\", function () {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"status\");",
						"  pm.expect(res).to.have.property(\"message\");",
						"  if (pm.response.code === 200 && res.status === \"success\") {",
						"    pm.expect(res).to.have.property(\"data\");",
						"    pm.expect(res.data).to.have.property(\"jobId\");",
						"    pm.collectionVariables.set(\"bulk_upload_jobId\", res.data.jobId);",
						"    console.log('‚úÖ Bulk upload started, jobId:', res.data.jobId);",
						"  }",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "formdata",
					"formdata": [
						{
						"key": "namespace",
						"value": "{{namespace}}",
						"type": "text"
						},
						{
						"key": "registry_name",
						"value": "{{registry_name}}",
						"type": "text",
						"disabled": true
						},
						{
						"key": "file",
						"type": "file"
						}
					]
					},
					"url": {
					"raw": "{{url}}/dedi/bulk-upload",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"bulk-upload"
					]
					},
					"description": "üìä BULK UPLOAD RECORDS\n\nUpload multiple records via CSV files. Creates an asynchronous job for processing large datasets.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Form Data:**\n- `namespace`: Target namespace ID (required)\n- `registry_name`: Target registry name (optional - if not provided, will auto-detect from CSV)\n- `file`: CSV file(s) to upload (required, max 100MB each, up to 1000 files)\n\n**CSV Format:**\n- Headers should match registry schema fields\n- Supports nested structures via dot notation\n- First row must contain field names\n\n**Response:**\n- Job ID for status tracking\n- Status check URL\n- Total file count\n\n**Asynchronous Processing:**\n1. Submit files ‚Üí Receive job ID\n2. Check status periodically\n3. Handle completion/errors\n\n**Rate Limits:** File size and count limits apply\n**File Requirements:** CSV format, valid UTF-8 encoding"
				},
				"response": []
			},
			{
				"name": "Get Job Status",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"// Set default job ID if not present",
						"if (!pm.variables.get(\"bulk_upload_jobId\")) {",
						"  pm.variables.set(\"bulk_upload_jobId\", \"<paste-your-job-id-here>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200, 401, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 404, 500]);",
						"});",
						"pm.test(\"Response has status and message\", function () {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"status\");",
						"  pm.expect(res).to.have.property(\"message\");",
						"  if (pm.response.code === 200 && res.status === \"success\") {",
						"    pm.expect(res).to.have.property(\"data\");",
						"    pm.expect(res.data).to.have.property(\"status\");",
						"    pm.expect(res.data).to.have.property(\"jobId\");",
						"    pm.expect(res.data).to.have.property(\"progress\");",
						"    console.log('Job Status:', res.data.status, '- Progress:', res.data.progress + '%');",
						"  }",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/bulk-upload/status/{{bulk_upload_jobId}}",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"bulk-upload",
						"status",
						"{{bulk_upload_jobId}}"
					]
					},
					"description": "üìà GET BULK UPLOAD JOB STATUS\n\nCheck the progress and status of a bulk upload job.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `jobId`: The job ID returned from bulk upload\n\n**Response Details:**\n- `status`: Job status (pending, processing, completed, failed, cancelled)\n- `progress`: Completion percentage (0-100)\n- `totalFiles`: Total number of files in the job\n- `processedFiles`: Number of files processed\n- `failedFiles`: Number of files that failed\n- `results`: Array of processing results\n- `error`: Error details if job failed\n\n**Job States:**\n- `pending`: Job queued, waiting to start\n- `processing`: Currently processing files\n- `completed`: All files processed successfully\n- `failed`: Job failed with errors\n- `cancelled`: Job was cancelled by user\n\n**Polling Recommendation:** Check status every 5-10 seconds during processing"
				},
				"response": []
			},
				{
				"name": "Get User Jobs",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200, 401, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([200, 401, 500]);",
						"});",
						"pm.test(\"Response has status and message\", function () {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"status\");",
						"  pm.expect(res).to.have.property(\"message\");",
						"  if (pm.response.code === 200 && res.status === \"success\") {",
						"    pm.expect(res).to.have.property(\"data\");",
						"    pm.expect(res.data).to.have.property(\"jobs\");",
						"    pm.expect(res.data.jobs).to.be.an('array');",
						"    pm.expect(res.data).to.have.property(\"pagination\");",
						"    console.log('‚úÖ Retrieved', res.data.jobs.length, 'user jobs');",
						"  }",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/bulk-upload/jobs?page=1&limit=10",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"bulk-upload",
						"jobs"
					],
					"query": [
						{
							"key": "page",
							"value": "1",
							"description": "Page number (default: 1)"
						},
						{
							"key": "limit",
							"value": "10",
							"description": "Number of jobs per page (default: 10)"
						}
					]
					},
					"description": "üìã GET USER BULK UPLOAD JOBS\n\nRetrieve a paginated list of all bulk upload jobs for the authenticated user.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Query Parameters:**\n- `page`: Page number (default: 1)\n- `limit`: Jobs per page (default: 10, max: 100)\n\n**Response Structure:**\n- `jobs`: Array of job objects with status and progress\n- `pagination`: Page info with total count and pages\n\n**Job Object Fields:**\n- `jobId`: Unique job identifier\n- `status`: Current job status\n- `progress`: Completion percentage\n- `totalFiles`: Number of files in job\n- `processedFiles`: Files successfully processed\n- `failedFiles`: Files that failed processing\n- `createdAt`: Job creation timestamp\n- `updatedAt`: Last update timestamp\n- `namespace`: Target namespace\n- `error`: Error message if failed\n\n**Use Cases:**\n- Job history tracking\n- Monitoring multiple uploads\n- Audit trail for data uploads"
				},
				"response": []
				}
			]
		},
		{
			"name": "delegation",
			"item": [
				{
				"name": "Add registry delegate",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// Ensure namespace and registry_name are set",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"registry_name\")) {",
						"  pm.variables.set(\"registry_name\", \"<your-registry-name>\");",
						"}",
						"// Ensure delegate_email is set",
						"if (!pm.variables.get(\"delegate_email\")) {",
						"  pm.variables.set(\"delegate_email\", \"adi.bhagavath+abws22@dhiway.com\");",
						"}",
						"// Ensure token is set (must be JWT, not cookie)",
						"if (!pm.variables.get(\"token\")) {",
						"  pm.variables.set(\"token\", \"<paste-access-token-here>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"email\": \"{{delegate_email}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/add-delegate",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"{{registry_name}}",
						"add-delegate"
					]
					},
					"description": "üë• ADD REGISTRY DELEGATE\n\nAdd a user as a delegate to a registry, granting them permission to manage records within that registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to add delegate to\n\n**Request Body:**\n- `email`: Email address of the user to add as delegate (required)\n\n**Use Cases:**\n- Grant registry access to team members\n- Delegate registry management responsibilities\n- Enable collaborative record management\n- Set up multi-user workflows"
				},
				"response": []
				},
				{
				"name": "Remove registry delegate",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"registry_name\")) {",
						"  pm.variables.set(\"registry_name\", \"<your-registry-name>\");",
						"}",
						"if (!pm.variables.get(\"delegate_email\")) {",
						"  pm.variables.set(\"delegate_email\", \"delegate@example.com\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"email\": \"{{delegate_email}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/remove-registry-delegate",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"{{registry_name}}",
						"remove-registry-delegate"
					]
					},
					"description": "üë•‚ùå REMOVE REGISTRY DELEGATE\n\nRemove a user's delegate access from a registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to remove delegate from\n\n**Request Body:**\n- `email`: Email address of the delegate to remove (required)\n\n**Use Cases:**\n- Revoke access from former team members\n- Update access permissions\n- Maintain registry security"
				},
				"response": []
				},
				{
				"name": "Get registry delegates",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"registry_name\")) {",
						"  pm.variables.set(\"registry_name\", \"<your-registry-name>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"if (pm.response.code === 200) {",
						"  pm.test(\"Response has delegates data\", function () {",
						"    const res = pm.response.json();",
						"    pm.expect(res).to.have.property(\"data\");",
						"    pm.expect(res.data).to.be.an('array');",
						"  });",
						"} else {",
						"  pm.test(\"Response has message\", function () {",
						"    pm.expect(pm.response.json()).to.have.property(\"message\");",
						"  });",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/get-delegates-by-registry",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"{{registry_name}}",
						"get-delegates-by-registry"
					]
					},
					"description": "üë•üìã GET REGISTRY DELEGATES\n\nRetrieve a list of all delegates for a specific registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to get delegates for\n\n**Response:**\n- Array of delegate user information\n- Includes email addresses and user details\n\n**Use Cases:**\n- Audit registry access permissions\n- Display current team members\n- Manage registry access control"
				},
				"response": []
				},
				{
				"name": "Add namespace delegate",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"delegate_email\")) {",
						"  pm.variables.set(\"delegate_email\", \"delegate@example.com\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"email\": \"{{delegate_email}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/add-namespace-delegate",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"add-namespace-delegate"
					]
					},
					"description": "üë• ADD NAMESPACE DELEGATE\n\nAdd a user as a delegate to a namespace, granting them permission to manage all registries within that namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n\n**Request Body:**\n- `email`: Email address of the user to add as delegate (required)\n\n**Use Cases:**\n- Grant namespace-wide access to administrators\n- Delegate namespace management responsibilities\n- Enable organizational collaboration"
				},
				"response": []
				},
				{
				"name": "Remove namespace delegate",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"delegate_email\")) {",
						"  pm.variables.set(\"delegate_email\", \"delegate@example.com\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"pm.test(\"Response has message\", function () {",
						"  pm.expect(pm.response.json()).to.have.property(\"message\");",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"email\": \"{{delegate_email}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/remove-namespace-delegate",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"remove-namespace-delegate"
					]
					},
					"description": "üë•‚ùå REMOVE NAMESPACE DELEGATE\n\nRemove a user's delegate access from a namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n\n**Request Body:**\n- `email`: Email address of the delegate to remove (required)\n\n**Use Cases:**\n- Revoke namespace access from former administrators\n- Update organizational permissions"
				},
				"response": []
				},
				{
				"name": "Get namespace delegates",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"if (!pm.variables.get(\"namespace\")) {",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"if (pm.response.code === 200) {",
						"  pm.test(\"Response has delegates data\", function () {",
						"    const res = pm.response.json();",
						"    pm.expect(res).to.have.property(\"data\");",
						"    pm.expect(res.data).to.be.an('array');",
						"  });",
						"} else {",
						"  pm.test(\"Response has message\", function () {",
						"    pm.expect(pm.response.json()).to.have.property(\"message\");",
						"  });",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
						"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/get-delegates-by-namespace",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"{{namespace}}",
						"get-delegates-by-namespace"
					]
					},
					"description": "üë•üìã GET NAMESPACE DELEGATES\n\nRetrieve a list of all delegates for a specific namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n\n**Response:**\n- Array of delegate user information\n- Includes email addresses and user details\n\n**Use Cases:**\n- Audit namespace access permissions\n- Display current administrators\n- Manage namespace access control"
				},
				"response": []
				}
			]
		},
		{
			"name": "domain",
			"item": [
				{
				"name": "Generate TXT",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables with helpful warnings",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"domain\") || pm.variables.get(\"domain\") === \"<your-domain.com>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'domain' variable (e.g., example.com) before running this request\");",
						"  pm.variables.set(\"domain\", \"<your-domain.com>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has message property\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"message\");",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const response = pm.response.json();",
						"  ",
						"  // Check for TXT in response (either direct or in data object)",
						"  if (response.txt) {",
						"    pm.test(\"Response contains generated TXT record\", function () {",
						"      pm.expect(response.txt).to.be.a(\"string\");",
						"      pm.expect(response.txt.length).to.be.greaterThan(0);",
						"    });",
						"    pm.collectionVariables.set(\"generated_txt\", response.txt);",
						"    console.log(\"‚úÖ Generated TXT record:\", response.txt);",
						"  } else if (response.data && response.data.txt) {",
						"    pm.test(\"Response data contains TXT record\", function () {",
						"      pm.expect(response.data.txt).to.be.a(\"string\");",
						"    });",
						"    pm.collectionVariables.set(\"generated_txt\", response.data.txt);",
						"    console.log(\"‚úÖ Generated TXT record:\", response.data.txt);",
						"  }",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/generate-dns-txt/{{namespace}}/{{domain}}",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"generate-dns-txt",
						"{{namespace}}",
						"{{domain}}"
					]
					},
					"description": "üîê GENERATE DNS TXT RECORD\n\nGenerate a DNS TXT record for domain verification.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace_id`: Target namespace ID\n- `domain`: Domain to verify (must be in global registry)\n\n**Validation Rules:**\n- Domain must contain a dot (valid format)\n- Domain must exist in global registry\n- Namespace must exist and not be already verified\n- Domain cannot be already verified by another namespace\n\n**Response Scenarios:**\n- 200: TXT record generated successfully\n- 200: TXT record already exists (returns existing)\n- 400: Invalid domain format or domain issues\n- 404: Namespace not found\n- 500: Internal server error\n\n**Response Format:**\n```json\n{\n  \"message\": \"Generated domain's DNS TXT record\",\n  \"txt\": \"verification_string\"\n}\n```\n\n**Usage Flow:**\n1. Generate TXT record\n2. Add TXT record to domain's DNS\n3. Call verify-domain endpoint\n4. Check verification status\n\n**Note:** Store the returned TXT record and add it to your domain's DNS settings before verification."
				},
				"response": []
				},
				{
				"name": "verify domain",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"",
						"// Note: Ensure you've added the generated TXT record to your domain's DNS before running this"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has message property\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"message\");",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  pm.test(\"Verification successful\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"Verification Successful\");",
						"  });",
						"  console.log(\"‚úÖ Domain verification successful!\");",
						"} else if (pm.response.code === 404) {",
						"  pm.test(\"Verification failed - TXT record not found\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"TXT record not found\");",
						"  });",
						"  console.log(\"‚ùå TXT record not found in DNS. Please ensure you've added it to your domain.\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"namespace_id\": \"{{namespace}}\"\n}",
					"options": {
						"raw": {
						"language": "json"
						}
					}
					},
					"url": {
					"raw": "{{url}}/dedi/verify-domain",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"verify-domain"
					]
					},
					"description": "‚úÖ VERIFY DOMAIN OWNERSHIP\n\nVerify domain ownership by checking the TXT record in DNS.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"namespace_id\": \"your-namespace-id\"\n}\n```\n\n**Prerequisites:**\n- TXT record must be generated first (generate-dns-txt)\n- TXT record must be added to domain's DNS settings\n- DNS propagation should be complete\n\n**Verification Process:**\n1. Checks if namespace exists\n2. Retrieves domain and TXT record from database\n3. Performs DNS lookup on the domain\n4. Validates TXT record matches generated value\n5. Updates namespace and domain verification status\n\n**Response Scenarios:**\n- 200: Verification successful\n- 400: Namespace ID missing or domain issues\n- 404: Namespace not found or TXT record not found in DNS\n- 500: DNS resolution errors\n\n**Important Notes:**\n- DNS changes may take time to propagate (up to 48 hours)\n- Only one domain can be verified per namespace\n- Domain cannot be shared between namespaces"
				},
				"response": []
				},
				{
				"name": "Check verification",
				"protocolProfileBehavior": {
					"disableBodyPruning": true
				},
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has verified property\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"verified\");",
						"  pm.expect(response.verified).to.be.a(\"boolean\");",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const response = pm.response.json();",
						"  ",
						"  if (response.verified) {",
						"    pm.test(\"Namespace is verified with domain\", function () {",
						"      pm.expect(response).to.have.property(\"domain\");",
						"      pm.expect(response.domain).to.be.a(\"string\");",
						"    });",
						"    console.log(`‚úÖ Namespace is verified with domain: ${response.domain}`);",
						"  } else {",
						"    pm.test(\"Namespace is not verified\", function () {",
						"      pm.expect(response.verified).to.be.false;",
						"      // Domain property should be undefined when not verified",
						"      pm.expect(response.domain).to.be.undefined;",
						"    });",
						"    console.log(\"‚ùå Namespace is not yet verified\");",
						"  }",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/check-verification/{{namespace}}",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"check-verification",
						"{{namespace}}"
					]
					},
					"description": "üîç CHECK DOMAIN VERIFICATION STATUS\n\nCheck the verification status of a namespace's associated domain.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace_id`: Target namespace ID to check\n\n**Response Format:**\n```json\n{\n  \"verified\": true,\n  \"domain\": \"example.com\"\n}\n```\n\n**Response Fields:**\n- `verified`: Boolean indicating verification status\n- `domain`: Domain name (only present if verified)\n\n**Response Scenarios:**\n- 200: Status retrieved successfully\n- 400: Namespace ID required\n- 404: Namespace not found\n- 500: Internal server error\n\n**Use Cases:**\n- Check if domain verification is complete\n- Retrieve verified domain for namespace\n- Validate namespace status before operations\n- Monitor verification progress\n\n**Note:** Domain field is only included in response when verification is successful."
				},
				"response": []
				},
				{
				"name": "get-dns-txt",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200, 400, 404, or 500\", function () {",
						"  pm.expect(pm.response.code).to.be.oneOf([200, 400, 404, 500]);",
						"});",
						"",
						"pm.test(\"Response has message or data\", function () {",
						"  const response = pm.response.json();",
						"  if (pm.response.code === 200) {",
						"    pm.expect(response).to.have.property(\"namespace_id\");",
						"    pm.expect(response).to.have.property(\"domain\");",
						"    pm.expect(response).to.have.property(\"txt\");",
						"    pm.expect(response).to.have.property(\"is_verified\");",
						"    console.log(`‚úÖ DNS TXT record retrieved for domain: ${response.domain}`);",
						"    console.log(`TXT record: ${response.txt}`);",
						"    console.log(`Verification status: ${response.is_verified ? 'Verified' : 'Not verified'}`);",
						"  } else {",
						"    pm.expect(response).to.have.property(\"message\");",
						"  }",
						"});"
						]
					}
					}
				],
				"request": {
					"auth": {
					"type": "noauth"
					},
					"method": "GET",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/get-dns-txt/{{namespace}}",
					"host": [
						"{{url}}"
					],
					"path": [
						"dedi",
						"get-dns-txt",
						"{{namespace}}"
					]
					},
					"description": "üìÑ GET DNS TXT RECORD\n\nRetrieve the generated DNS TXT record for a namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace_id`: Target namespace ID\n\n**Response Format:**\n```json\n{\n  \"namespace_id\": \"your-namespace-id\",\n  \"domain\": \"example.com\",\n  \"txt\": \"verification_string\", \n  \"is_verified\": false\n}\n```\n\n**Response Fields:**\n- `namespace_id`: The namespace identifier\n- `domain`: Associated domain name\n- `txt`: Generated verification TXT record\n- `is_verified`: Current verification status\n\n**Response Scenarios:**\n- 200: TXT record retrieved successfully\n- 400: Namespace ID required\n- 404: Domain not found for namespace\n- 500: Internal server error\n\n**Use Cases:**\n- Retrieve TXT record after generation\n- Check domain and verification status\n- Get verification string for DNS configuration\n- Audit domain verification setup\n\n**Note:** This endpoint returns the TXT record regardless of verification status."
				},
				"response": []
				}
			]
		},
		{
			"name": "update",
			"item": [
				{
				"name": "update namespace",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"",
						"// Generate unique test data for update",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueName = generateUniqueString(\"updated_name\");",
						"const uniqueDesc = generateUniqueString(\"updated_desc\");",
						"pm.variables.set(\"ns_name_update\", uniqueName);",
						"pm.variables.set(\"ns_desc_update\", uniqueDesc);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 201 or error\", function () {",
						"  pm.expect([201, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has message and data properties\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"message\");",
						"  if (pm.response.code === 201) {",
						"    pm.expect(response).to.have.property(\"data\");",
						"  }",
						"});",
						"",
						"if (pm.response.code === 201) {",
						"  const response = pm.response.json();",
						"  ",
						"  pm.test(\"Successful update response\", function () {",
						"    pm.expect(response.message).to.equal(\"namespace updated\");",
						"    pm.expect(response.data).to.have.property(\"digest\");",
						"  });",
						"  ",
						"  // Store the digest for further operations",
						"  pm.collectionVariables.set(\"namespace_digest\", response.data.digest);",
						"  console.log(\"‚úÖ Namespace updated successfully with digest:\", response.data.digest);",
						"} else if (pm.response.code === 403) {",
						"  pm.test(\"Authorization error\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"privileges\");",
						"  });",
						"} else if (pm.response.code === 404) {",
						"  pm.test(\"Namespace not found\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"not found\");",
						"  });",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"name\": \"{{ns_name_update}}\",\n  \"description\": \"{{ns_desc_update}}\",\n  \"meta\": {},\n  \"ttl\": 3600\n}",
					"options": { "raw": { "language": "json" } }
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/update-namespace",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "update-namespace"]
					},
					"description": "‚úèÔ∏è UPDATE NAMESPACE\n\nUpdate namespace properties like name, description, metadata, and TTL.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain to update\n\n**Request Body:**\n```json\n{\n  \"name\": \"updated_namespace_name\",\n  \"description\": \"updated description\",\n  \"meta\": {\"key\": \"value\"},\n  \"ttl\": 3600\n}\n```\n\n**Update Rules:**\n- Either name or description must be provided\n- Name cannot be empty if provided\n- User must have authorization to namespace\n- Creates new version while preserving history\n\n**Response Scenarios:**\n- 201: Namespace updated successfully\n- 400: Invalid input (missing name/description, empty name, invalid meta)\n- 401: Authentication required\n- 403: Insufficient privileges\n- 404: Namespace or user not found\n- 500: Internal server error\n\n**Response Format:**\n```json\n{\n  \"message\": \"namespace updated\",\n  \"data\": {\"digest\": \"hash_value\"}\n}\n```\n\n**Note:** Updates create a new version with incremented version_count while marking previous version as invalid."
				},
				"response": []
				},
				{
				"name": "update registry",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"registry_name\") || pm.variables.get(\"registry_name\") === \"<your-registry-name>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'registry_name' variable before running this request\");",
						"  pm.variables.set(\"registry_name\", \"<your-registry-name>\");",
						"}",
						"",
						"// Generate unique test data for update",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueDesc = generateUniqueString(\"updated_registry_desc\");",
						"pm.variables.set(\"reg_desc_update\", uniqueDesc);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has message property\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"message\");",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const response = pm.response.json();",
						"  ",
						"  pm.test(\"Successful registry update\", function () {",
						"    pm.expect(response.message).to.equal(\"Registry updated\");",
						"    pm.expect(response).to.have.property(\"data\");",
						"    pm.expect(response.data).to.have.property(\"digest\");",
						"  });",
						"  ",
						"  // Store the digest for further operations",
						"  pm.collectionVariables.set(\"registry_digest\", response.data.digest);",
						"  console.log(\"‚úÖ Registry updated successfully with digest:\", response.data.digest);",
						"} else if (pm.response.code === 403) {",
						"  pm.test(\"Authorization error\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"privileges\");",
						"  });",
						"} else if (pm.response.code === 404) {",
						"  pm.test(\"Registry or namespace not found\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"not found\");",
						"  });",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"description\": \"{{reg_desc_update}}\",\n  \"meta\": {},\n  \"query_allowed\": true,\n  \"ttl\": 3600\n}",
					"options": { "raw": { "language": "json" } }
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/update-registry",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "update-registry"]
					},
					"description": "üìù UPDATE REGISTRY\n\nUpdate registry properties like description, metadata, query permissions, and TTL.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Name of the registry to update\n\n**Request Body:**\n```json\n{\n  \"description\": \"updated description\",\n  \"meta\": {\"key\": \"value\"},\n  \"query_allowed\": true,\n  \"tag\": \"updated_tag\",\n  \"ttl\": 3600\n}\n```\n\n**Update Rules:**\n- At least one field must be provided for update\n- User must have authorization to namespace and registry\n- Creates new version while preserving history\n- Cannot update schema (read-only after creation)\n\n**Response Scenarios:**\n- 200: Registry updated successfully\n- 400: Invalid input (missing namespace/registry_name, invalid meta)\n- 401: Authentication required\n- 403: Insufficient privileges\n- 404: Namespace or registry not found\n- 500: Internal server error\n\n**Response Format:**\n```json\n{\n  \"message\": \"Registry updated\",\n  \"data\": {\"digest\": \"hash_value\"}\n}\n```\n\n**Note:** Updates increment version_count and create new registry version while maintaining immutable history."
				},
				"response": []
				},
				{
				"name": "update record",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script",
						"",
						"// Validate required variables",
						"if (!pm.variables.get(\"namespace\") || pm.variables.get(\"namespace\") === \"<your-namespace-id>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'namespace' variable before running this request\");",
						"  pm.variables.set(\"namespace\", \"<your-namespace-id>\");",
						"}",
						"if (!pm.variables.get(\"registry_name\") || pm.variables.get(\"registry_name\") === \"<your-registry-name>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'registry_name' variable before running this request\");",
						"  pm.variables.set(\"registry_name\", \"<your-registry-name>\");",
						"}",
						"if (!pm.variables.get(\"record_name\") || pm.variables.get(\"record_name\") === \"<your-record-name>\") {",
						"  console.warn(\"‚ö†Ô∏è WARNING: Please set a valid 'record_name' variable before running this request\");",
						"  pm.variables.set(\"record_name\", \"<your-record-name>\");",
						"}",
						"",
						"// Generate unique test data for update",
						"function generateUniqueString(prefix) {",
						"  const randomPart = Math.random().toString(16).slice(2);",
						"  const timestamp = Date.now().toString(36);",
						"  return `${prefix}_${timestamp}_${randomPart}`;",
						"}",
						"const uniqueDesc = generateUniqueString(\"updated_record_desc\");",
						"pm.variables.set(\"rec_desc_update\", uniqueDesc);"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"pm.test(\"Response has message property\", function () {",
						"  const response = pm.response.json();",
						"  pm.expect(response).to.have.property(\"message\");",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const response = pm.response.json();",
						"  ",
						"  pm.test(\"Successful record update\", function () {",
						"    pm.expect(response.message).to.include(\"updated\");",
						"    pm.expect(response).to.have.property(\"data\");",
						"    if (response.data) {",
						"      pm.expect(response.data).to.have.property(\"digest\");",
						"    }",
						"  });",
						"  ",
						"  // Store the digest if available",
						"  if (response.data && response.data.digest) {",
						"    pm.collectionVariables.set(\"record_digest\", response.data.digest);",
						"    console.log(\"‚úÖ Record updated successfully with digest:\", response.data.digest);",
						"  }",
						"} else if (pm.response.code === 403) {",
						"  pm.test(\"Authorization error\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.include(\"privileges\");",
						"  });",
						"} else if (pm.response.code === 404) {",
						"  pm.test(\"Record not found or invalid state\", function () {",
						"    const response = pm.response.json();",
						"    pm.expect(response.message).to.satisfy((msg) => {",
						"      return msg.includes(\"not found\") || msg.includes(\"cannot be updated\");",
						"    });",
						"  });",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"body": {
					"mode": "raw",
					"raw": "{\n  \"description\": \"{{rec_desc_update}}\",\n  \"details\": {},\n  \"meta\": {},\n  \"valid_till\": \"\",\n  \"ttl\": 3600\n}",
					"options": { "raw": { "language": "json" } }
					},
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/update-record",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "{{record_name}}", "update-record"]
					},
					"description": "üìù UPDATE RECORD\n\nUpdate record properties like description, details, metadata, and TTL. Only published (live) records can be updated.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Name of the record to update\n\n**Request Body:**\n```json\n{\n  \"description\": \"updated description\",\n  \"details\": {\"updated\": \"data\"},\n  \"meta\": {\"key\": \"value\"},\n  \"valid_till\": \"2024-12-31T23:59:59Z\",\n  \"ttl\": 7200\n}\n```\n\n**Update Rules:**\n- At least details field must be provided\n- Record must be in 'draft' or 'live' state\n- Cannot update expired, revoked, or suspended records\n- User must have registry authorization\n- Schema validation applies if registry has schema\n\n**Response Scenarios:**\n- 200: Record updated successfully\n- 400: Invalid input (missing details, invalid meta)\n- 401: Authentication required\n- 403: Insufficient privileges\n- 404: Record/registry/namespace not found or invalid state\n- 500: Internal server error\n\n**Response Format:**\n```json\n{\n  \"message\": \"Record updated successfully\",\n  \"data\": {\"digest\": \"hash_value\"}\n}\n```\n\n**Important Notes:**\n- Updates create new version with incremented version_count\n- Original record is marked as invalid\n- Schema validation enforced if registry defines schema\n- Chain anchoring respects registry's fields_to_anchor settings"
				},
				"response": []
				}
			]
		},
		{
			"name": "state management",
			"item": [
				{
				"name": "revoke registry",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Regsitry has been revoked\");",
						"  console.log(\"‚úÖ Registry revoked successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Registry not found or already revoked\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/revoke-registry",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "revoke-registry"]
					},
					"description": "üö´ REVOKE REGISTRY\n\nPermanently revokes a registry, making it inactive and preventing any new records from being created.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to revoke\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Registry must not be already revoked\n- Registry must not be archived\n\n**Response (200):**\n```json\n{\n  \"message\": \"Regsitry has been revoked\"\n}\n```\n\n**Error Cases:**\n- **404**: Registry not found or already revoked\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Important:** This action is permanent and cannot be undone. Use reinstate if you need to temporarily disable a registry."
				},
				"response": []
				},
				{
				"name": "suspend registry",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Registry has been suspended\");",
						"  console.log(\"‚úÖ Registry suspended successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Registry not found or already suspended\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/suspend-registry",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "suspend-registry"]
					},
					"description": "‚è∏Ô∏è SUSPEND REGISTRY\n\nTemporarily suspends a registry, disabling it without permanent revocation. Suspended registries cannot accept new records but can be reinstated later.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to suspend\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Registry must not be already suspended, revoked, or archived\n- Registry must be in active state\n\n**Response (200):**\n```json\n{\n  \"message\": \"Registry has been suspended\"\n}\n```\n\n**Error Cases:**\n- **404**: Registry not found or already suspended\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Use Cases:**\n- Temporarily disable registry during maintenance\n- Pause registry operations without permanent revocation\n- Quick response to security concerns\n- Administrative control over registry availability\n\n**Difference from Revoke:**\n- Suspend is temporary and reversible\n- Revoke is permanent and cannot be undone\n- Suspended registries can be reinstated\n- Revoked registries require special reinstatement process"
				},
				"response": []
				},
				{
				"name": "reinstate registry",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Registry has been reinstated\");",
						"  console.log(\"‚úÖ Registry reinstated successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Registry not found or not revoked\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/reinstate-registry",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "reinstate-registry"]
					},
					"description": "‚ôªÔ∏è REINSTATE REGISTRY\n\nReinstates a previously revoked registry, making it active again for new record creation.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to reinstate\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Registry must be currently revoked\n- Registry must not be archived\n\n**Response (200):**\n```json\n{\n  \"message\": \"Registry has been reinstated\"\n}\n```\n\n**Error Cases:**\n- **404**: Registry not found or not in revoked state\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Use Cases:**\n- Reactivating temporarily disabled registries\n- Restoring accidentally revoked registries\n- Managing registry lifecycle"
				},
				"response": []
				},
				{
				"name": "suspend record",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Record has been suspended\");",
						"  console.log(\"‚úÖ Record suspended successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Record not found or cannot be suspended (revoked/expired)\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/suspend-record",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "{{record_name}}", "suspend-record"]
					},
					"description": "‚è∏Ô∏è SUSPEND RECORD\n\nTemporarily suspends a record, making it inactive while preserving its data for potential reinstatement.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Record name to suspend\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Record must exist and be in 'live' state\n- Record must not be revoked or expired\n\n**Response (200):**\n```json\n{\n  \"message\": \"Record has been suspended\"\n}\n```\n\n**Error Cases:**\n- **404**: Record not found or cannot be suspended\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Use Cases:**\n- Temporarily disabling records under investigation\n- Compliance-related record suspension\n- Managing record lifecycle states\n\n**Note:** Suspended records can be reinstated. This action is reversible."
				},
				"response": []
				},
				{
				"name": "reinstate record",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Record has been reinstated\");",
						"  console.log(\"‚úÖ Record reinstated successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Record not found, already active, or cannot be reinstated (revoked/expired)\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/reinstate-record",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "{{record_name}}", "reinstate-record"]
					},
					"description": "‚ôªÔ∏è REINSTATE RECORD\n\nReinstates a previously suspended record, making it active and available for queries again.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Record name to reinstate\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Record must exist and be in 'suspended' state\n- Record must not be revoked or expired\n\n**Response (200):**\n```json\n{\n  \"message\": \"Record has been reinstated\"\n}\n```\n\n**Error Cases:**\n- **404**: Record not found, already active, or cannot be reinstated\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Use Cases:**\n- Reactivating suspended records after review\n- Restoring accidentally suspended records\n- Managing record compliance workflows\n\n**Note:** Only suspended records can be reinstated. Revoked and expired records cannot be restored."
				},
				"response": []
				},
				{
				"name": "revoke record",
				"event": [
					{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"exec": [
						"// ‚úÖ Authentication is handled automatically by the global collection script"
						]
					}
					},
					{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"exec": [
						"pm.test(\"Status code is 200 or error\", function () {",
						"  pm.expect([200, 400, 401, 403, 404, 500]).to.include(pm.response.code);",
						"});",
						"",
						"if (pm.response.code === 200) {",
						"  const res = pm.response.json();",
						"  pm.expect(res).to.have.property(\"message\");",
						"  pm.expect(res.message).to.equal(\"Record has been revoked\");",
						"  console.log(\"‚úÖ Record revoked successfully\");",
						"} else if (pm.response.code === 400) {",
						"  console.log(\"‚ö†Ô∏è Bad request - check required parameters\");",
						"} else if (pm.response.code === 401) {",
						"  console.log(\"üîê Authentication required\");",
						"} else if (pm.response.code === 403) {",
						"  console.log(\"üö´ Insufficient privileges\");",
						"} else if (pm.response.code === 404) {",
						"  console.log(\"üìÅ Record not found or cannot be revoked (already expired)\");",
						"}"
						]
					}
					}
				],
				"request": {
					"auth": { "type": "noauth" },
					"method": "POST",
					"header": [],
					"url": {
					"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/revoke-record",
					"host": ["{{url}}"],
					"path": ["dedi", "{{namespace}}", "{{registry_name}}", "{{record_name}}", "revoke-record"]
					},
					"description": "üö´ REVOKE RECORD\n\nPermanently revokes a record, making it invalid and preventing any future use. This action is irreversible.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Record name to revoke\n\n**Prerequisites:**\n- User must have authorization to the registry\n- Record must exist and not be already expired\n\n**Response (200):**\n```json\n{\n  \"message\": \"Record has been revoked\"\n}\n```\n\n**Error Cases:**\n- **404**: Record not found or already expired\n- **403**: Insufficient privileges\n- **400**: Missing required parameters\n\n**Use Cases:**\n- Invalidating compromised records\n- Compliance-related record revocation\n- Permanent record invalidation\n\n**Important:** This action is permanent and cannot be undone. Revoked records cannot be reinstated."
				},
				"response": []
				}
			]
		},
		{
			"name": "access",
			"item": [
				{
					"name": "lookup",
					"item": [
						{
						"name": "namespace lookup",
						"event": [
							{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üîê ACCESS SECTION - NAMESPACE LOOKUP",
								"// Authentication is handled automatically by the global collection script",
								"",
								"// Ensure namespace variable is set for testing",
								"if (!pm.collectionVariables.get('namespace')) {",
								"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
								"    pm.collectionVariables.set('namespace', 'test-namespace');",
								"}"
								]
							}
							},
							{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üß™ NAMESPACE LOOKUP VALIDATION",
								"pm.test(\"‚úÖ Status code is valid\", function () {",
								"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
								"});",
								"",
								"const responseJson = pm.response.json();",
								"pm.test(\"üìÑ Response has required structure\", function () {",
								"    pm.expect(responseJson).to.have.property('message');",
								"    if (pm.response.code === 200) {",
								"        pm.expect(responseJson).to.have.property('data');",
								"    }",
								"});",
								"",
								"// ‚úÖ SUCCESS CASE (200)",
								"if (pm.response.code === 200) {",
								"    pm.test(\"üéØ Success message is correct\", function () {",
								"        pm.expect(responseJson.message).to.equal('Namespace details retrieved successfully');",
								"    });",
								"    ",
								"    const data = responseJson.data;",
								"    pm.test(\"üóÇÔ∏è Data has required namespace fields\", function () {",
								"        pm.expect(data).to.have.property('name');",
								"        pm.expect(data).to.have.property('namespace_id');",
								"        pm.expect(data).to.have.property('digest');",
								"        pm.expect(data).to.have.property('description');",
								"        pm.expect(data).to.have.property('created_by');",
								"        pm.expect(data).to.have.property('genesis');",
								"        pm.expect(data).to.have.property('created_at');",
								"        pm.expect(data).to.have.property('updated_at');",
								"        pm.expect(data).to.have.property('version_count');",
								"        pm.expect(data).to.have.property('version');",
								"        pm.expect(data).to.have.property('registry_count');",
								"        pm.expect(data).to.have.property('ttl');",
								"    });",
								"    ",
								"    pm.test(\"üî¢ Data types are correct\", function () {",
								"        pm.expect(typeof data.name).to.equal('string');",
								"        pm.expect(typeof data.namespace_id).to.equal('string');",
								"        pm.expect(typeof data.digest).to.equal('string');",
								"        pm.expect(typeof data.description).to.equal('string');",
								"        pm.expect(typeof data.created_by).to.equal('string');",
								"        pm.expect(typeof data.version_count).to.equal('number');",
								"        pm.expect(typeof data.registry_count).to.equal('number');",
								"        pm.expect(typeof data.ttl).to.equal('number');",
								"    });",
								"    ",
								"    // Store for chaining",
								"    pm.collectionVariables.set('namespace_id', data.namespace_id);",
								"    console.log('‚úÖ Namespace lookup successful:', data.namespace_id);",
								"}",
								"",
								"// ‚ùå ERROR CASES",
								"else if (pm.response.code === 400) {",
								"    pm.test(\"‚ö†Ô∏è Bad request has appropriate message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Invalid input: namespace is missing or empty',",
								"            'Invalid input: as_on date format is invalid'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 401) {",
								"    pm.test(\"üîí Unauthorized error message\", function () {",
								"        pm.expect(responseJson.message).to.include('Unauthorized');",
								"    });",
								"}",
								"else if (pm.response.code === 404) {",
								"    pm.test(\"üîç Not found error message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Namespace not found',",
								"            'User not found'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 500) {",
								"    pm.test(\"üí• Server error message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Database query failed',",
								"            'An unexpected error occurred while retrieving namespace details'",
								"        ]);",
								"    });",
								"}"
								]
							}
							}
						],
						"request": {
							"auth": { "type": "noauth" },
							"method": "GET",
							"header": [],
							"url": {
							"raw": "{{url}}/dedi/lookup/{{namespace}}",
							"host": ["{{url}}"],
							"path": ["dedi", "lookup", "{{namespace}}"],
							"query": [
								{
									"key": "version_id",
									"value": "",
									"description": "Specific version to lookup (optional)",
									"disabled": true
								},
								{
									"key": "as_on",
									"value": "",
									"description": "Historical lookup date (YYYY-MM-DD format, optional)",
									"disabled": true
								}
							]
							},
							"description": "üîç NAMESPACE LOOKUP\n\nRetrieve detailed information about a specific namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain to lookup\n\n**Query Parameters (Optional):**\n- `version_id`: Specific version to retrieve\n- `as_on`: Historical lookup date (YYYY-MM-DD)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Namespace details retrieved successfully\",\n  \"data\": {\n    \"name\": \"namespace-name\",\n    \"namespace_id\": \"ns_123...\",\n    \"domain\": \"example.com\",\n    \"digest\": \"0x123...\",\n    \"description\": \"Namespace description\",\n    \"created_by\": \"profile_id\",\n    \"genesis\": \"0x456...\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"version_count\": 5,\n    \"version\": \"0x789...\",\n    \"meta\": {},\n    \"registry_count\": 10,\n    \"ttl\": 3600,\n    \"is_verified\": true\n  }\n}\n```\n\n**Error Cases:**\n- **400**: Invalid input (missing namespace or invalid date)\n- **401**: Unauthorized (invalid token)\n- **404**: Namespace not found or user not found\n- **500**: Database error or internal server error\n\n**Use Cases:**\n- Retrieve namespace metadata\n- Verify namespace existence\n- Get namespace configuration details"
						},
						"response": []
						},
						{
						"name": "registry lookup",
						"event": [
							{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üîê ACCESS SECTION - REGISTRY LOOKUP",
								"// Authentication is handled automatically by the global collection script",
								"",
								"// Ensure required variables are set for testing",
								"if (!pm.collectionVariables.get('namespace')) {",
								"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
								"    pm.collectionVariables.set('namespace', 'test-namespace');",
								"}",
								"if (!pm.collectionVariables.get('registry_name')) {",
								"    console.log('‚ö†Ô∏è Warning: registry_name variable not set');",
								"    pm.collectionVariables.set('registry_name', 'test-registry');",
								"}"
								]
							}
							},
							{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üß™ REGISTRY LOOKUP VALIDATION",
								"pm.test(\"‚úÖ Status code is valid\", function () {",
								"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
								"});",
								"",
								"const responseJson = pm.response.json();",
								"pm.test(\"üìÑ Response has required structure\", function () {",
								"    pm.expect(responseJson).to.have.property('message');",
								"    if (pm.response.code === 200) {",
								"        pm.expect(responseJson).to.have.property('data');",
								"    }",
								"});",
								"",
								"// ‚úÖ SUCCESS CASE (200)",
								"if (pm.response.code === 200) {",
								"    pm.test(\"üéØ Success message is correct\", function () {",
								"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
								"    });",
								"    ",
								"    const data = responseJson.data;",
								"    pm.test(\"üóÇÔ∏è Data has required registry fields\", function () {",
								"        pm.expect(data).to.have.property('namespace');",
								"        pm.expect(data).to.have.property('namespace_id');",
								"        pm.expect(data).to.have.property('registry_id');",
								"        pm.expect(data).to.have.property('registry_name');",
								"        pm.expect(data).to.have.property('digest');",
								"        pm.expect(data).to.have.property('description');",
								"        pm.expect(data).to.have.property('created_by');",
								"        pm.expect(data).to.have.property('schema');",
								"        pm.expect(data).to.have.property('genesis');",
								"        pm.expect(data).to.have.property('created_at');",
								"        pm.expect(data).to.have.property('updated_at');",
								"        pm.expect(data).to.have.property('version_count');",
								"        pm.expect(data).to.have.property('version');",
								"        pm.expect(data).to.have.property('record_count');",
								"        pm.expect(data).to.have.property('query_allowed');",
								"        pm.expect(data).to.have.property('ttl');",
								"    });",
								"    ",
								"    pm.test(\"üî¢ Data types are correct\", function () {",
								"        pm.expect(typeof data.namespace).to.equal('string');",
								"        pm.expect(typeof data.namespace_id).to.equal('string');",
								"        pm.expect(typeof data.registry_id).to.equal('string');",
								"        pm.expect(typeof data.registry_name).to.equal('string');",
								"        pm.expect(typeof data.digest).to.equal('string');",
								"        pm.expect(typeof data.description).to.equal('string');",
								"        pm.expect(typeof data.created_by).to.equal('string');",
								"        pm.expect(typeof data.version_count).to.equal('number');",
								"        pm.expect(typeof data.record_count).to.equal('number');",
								"        pm.expect(typeof data.query_allowed).to.equal('boolean');",
								"        pm.expect(typeof data.ttl).to.equal('number');",
								"    });",
								"    ",
								"    // Store for chaining",
								"    pm.collectionVariables.set('registry_id', data.registry_id);",
								"    console.log('‚úÖ Registry lookup successful:', data.registry_id);",
								"}",
								"",
								"// ‚ùå ERROR CASES",
								"else if (pm.response.code === 400) {",
								"    pm.test(\"‚ö†Ô∏è Bad request has appropriate message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Namespace is missing',",
								"            'Registry name is missing',",
								"            'Invalid JWT token'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 401) {",
								"    pm.test(\"üîí Unauthorized error message\", function () {",
								"        pm.expect(responseJson.message).to.include('Unauthorized');",
								"    });",
								"}",
								"else if (pm.response.code === 404) {",
								"    pm.test(\"üîç Not found error message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Namespace not found',",
								"            'Registry not found',",
								"            'User not found'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 500) {",
								"    pm.test(\"üí• Server error message\", function () {",
								"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
								"    });",
								"}"
								]
							}
							}
						],
						"request": {
							"auth": { "type": "noauth" },
							"method": "GET",
							"header": [],
							"url": {
							"raw": "{{url}}/dedi/lookup/{{namespace}}/{{registry_name}}",
							"host": ["{{url}}"],
							"path": ["dedi", "lookup", "{{namespace}}", "{{registry_name}}"],
							"query": [
								{ 
									"key": "version_id", 
									"value": "",
									"description": "Specific version to lookup (optional)",
									"disabled": true
								},
								{
									"key": "as_on",
									"value": "",
									"description": "Historical lookup date (YYYY-MM-DD format, optional)",
									"disabled": true
								}
							]
							},
							"description": "üîç REGISTRY LOOKUP\n\nRetrieve detailed information about a specific registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name to lookup\n\n**Query Parameters (Optional):**\n- `version_id`: Specific version to retrieve\n- `as_on`: Historical lookup date (YYYY-MM-DD)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"namespace\": \"namespace-name\",\n    \"namespace_id\": \"ns_123...\",\n    \"registry_id\": \"reg_456...\",\n    \"registry_name\": \"registry-name\",\n    \"digest\": \"0x123...\",\n    \"description\": \"Registry description\",\n    \"created_by\": \"profile_id\",\n    \"tag\": \"v1.0\",\n    \"schema\": {},\n    \"genesis\": \"0x456...\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"meta\": {},\n    \"record_count\": 25,\n    \"version_count\": 3,\n    \"version\": \"0x789...\",\n    \"query_allowed\": true,\n    \"is_revoked\": false,\n    \"is_archived\": false,\n    \"ttl\": 600\n  }\n}\n```\n\n**Error Cases:**\n- **400**: Missing parameters or invalid token\n- **401**: Unauthorized (invalid token)\n- **404**: Namespace, registry, or user not found\n- **500**: Internal server error\n\n**Use Cases:**\n- Retrieve registry metadata\n- Verify registry existence\n- Check registry permissions and configuration"
						},
						"response": []
						},
						{
						"name": "record lookup",
						"event": [
							{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üîê ACCESS SECTION - RECORD LOOKUP",
								"// Authentication is handled automatically by the global collection script",
								"",
								"// Ensure required variables are set for testing",
								"if (!pm.collectionVariables.get('namespace')) {",
								"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
								"    pm.collectionVariables.set('namespace', 'test-namespace');",
								"}",
								"if (!pm.collectionVariables.get('registry_name')) {",
								"    console.log('‚ö†Ô∏è Warning: registry_name variable not set');",
								"    pm.collectionVariables.set('registry_name', 'test-registry');",
								"}",
								"if (!pm.collectionVariables.get('record_name')) {",
								"    console.log('‚ö†Ô∏è Warning: record_name variable not set');",
								"    pm.collectionVariables.set('record_name', 'test-record');",
								"}"
								]
							}
							},
							{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
								"// üß™ RECORD LOOKUP VALIDATION",
								"pm.test(\"‚úÖ Status code is valid\", function () {",
								"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
								"});",
								"",
								"const responseJson = pm.response.json();",
								"pm.test(\"üìÑ Response has required structure\", function () {",
								"    pm.expect(responseJson).to.have.property('message');",
								"    if (pm.response.code === 200) {",
								"        pm.expect(responseJson).to.have.property('data');",
								"    }",
								"});",
								"",
								"// ‚úÖ SUCCESS CASES (200)",
								"if (pm.response.code === 200) {",
								"    // Handle both successful response and expired record",
								"    pm.test(\"üéØ Success message is correct\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Resource retrieved successfully',",
								"            'Record has been expired'",
								"        ]);",
								"    });",
								"    ",
								"    const data = responseJson.data;",
								"    pm.test(\"üóÇÔ∏è Data has required record fields\", function () {",
								"        pm.expect(data).to.have.property('namespace');",
								"        pm.expect(data).to.have.property('namespace_id');",
								"        pm.expect(data).to.have.property('registry_id');",
								"        pm.expect(data).to.have.property('registry_name');",
								"        pm.expect(data).to.have.property('record_id');",
								"        pm.expect(data).to.have.property('record_name');",
								"        pm.expect(data).to.have.property('description');",
								"        pm.expect(data).to.have.property('digest');",
								"        pm.expect(data).to.have.property('schema');",
								"        pm.expect(data).to.have.property('version_count');",
								"        pm.expect(data).to.have.property('version');",
								"        pm.expect(data).to.have.property('details');",
								"        pm.expect(data).to.have.property('genesis');",
								"        pm.expect(data).to.have.property('created_at');",
								"        pm.expect(data).to.have.property('updated_at');",
								"        pm.expect(data).to.have.property('created_by');",
								"        pm.expect(data).to.have.property('state');",
								"        pm.expect(data).to.have.property('ttl');",
								"    });",
								"    ",
								"    pm.test(\"üî¢ Data types are correct\", function () {",
								"        pm.expect(typeof data.namespace).to.equal('string');",
								"        pm.expect(typeof data.namespace_id).to.equal('string');",
								"        pm.expect(typeof data.registry_id).to.equal('string');",
								"        pm.expect(typeof data.registry_name).to.equal('string');",
								"        pm.expect(typeof data.record_id).to.equal('string');",
								"        pm.expect(typeof data.record_name).to.equal('string');",
								"        pm.expect(typeof data.description).to.equal('string');",
								"        pm.expect(typeof data.digest).to.equal('string');",
								"        pm.expect(typeof data.created_by).to.equal('string');",
								"        pm.expect(typeof data.version_count).to.equal('number');",
								"        pm.expect(typeof data.state).to.equal('string');",
								"        pm.expect(typeof data.ttl).to.equal('number');",
								"    });",
								"    ",
								"    // Store for chaining",
								"    pm.collectionVariables.set('record_id', data.record_id);",
								"    console.log('‚úÖ Record lookup successful:', data.record_id);",
								"}",
								"",
								"// ‚ùå ERROR CASES",
								"else if (pm.response.code === 400) {",
								"    pm.test(\"‚ö†Ô∏è Bad request has appropriate message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Namespace is missing',",
								"            'Registry name is missing',",
								"            'Record name is missing',",
								"            'Invalid JWT token'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 401) {",
								"    pm.test(\"üîí Unauthorized error message\", function () {",
								"        pm.expect(responseJson.message).to.include('Unauthorized');",
								"    });",
								"}",
								"else if (pm.response.code === 404) {",
								"    pm.test(\"üîç Not found error message\", function () {",
								"        pm.expect(responseJson.message).to.be.oneOf([",
								"            'Namespace not found',",
								"            'Registry not found',",
								"            'Record not found',",
								"            'User not found'",
								"        ]);",
								"    });",
								"}",
								"else if (pm.response.code === 500) {",
								"    pm.test(\"üí• Server error message\", function () {",
								"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
								"    });",
								"}"
								]
							}
							}
						],
						"request": {
							"auth": { "type": "noauth" },
							"method": "GET",
							"header": [],
							"url": {
							"raw": "{{url}}/dedi/lookup/{{namespace}}/{{registry_name}}/{{record_name}}",
							"host": ["{{url}}"],
							"path": ["dedi", "lookup", "{{namespace}}", "{{registry_name}}", "{{record_name}}"],
							"query": [
								{
									"key": "version_id",
									"value": "",
									"description": "Specific version to lookup (optional)",
									"disabled": true
								},
								{
									"key": "as_on",
									"value": "",
									"description": "Historical lookup date (YYYY-MM-DD format, optional)",
									"disabled": true
								}
							]
							},
							"description": "üîç RECORD LOOKUP\n\nRetrieve detailed information about a specific record.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name containing the record\n- `record_name`: Record name to lookup\n\n**Query Parameters (Optional):**\n- `version_id`: Specific version to retrieve\n- `as_on`: Historical lookup date (YYYY-MM-DD)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"namespace\": \"namespace-name\",\n    \"namespace_id\": \"ns_123...\",\n    \"registry_id\": \"reg_456...\",\n    \"registry_name\": \"registry-name\",\n    \"record_id\": \"rec_789...\",\n    \"record_name\": \"record-name\",\n    \"description\": \"Record description\",\n    \"digest\": \"0x123...\",\n    \"schema\": {},\n    \"version_count\": 2,\n    \"version\": \"0x456...\",\n    \"details\": {},\n    \"meta\": {},\n    \"genesis\": \"0x789...\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"created_by\": \"profile_id\",\n    \"state\": \"live\",\n    \"ttl\": 3600\n  }\n}\n```\n\n**Expired Record Response (200):**\n```json\n{\n  \"message\": \"Record has been expired\",\n  \"data\": { /* same structure but state: 'expired' */ }\n}\n```\n\n**Error Cases:**\n- **400**: Missing parameters or invalid token\n- **401**: Unauthorized (invalid token)\n- **404**: Namespace, registry, record, or user not found\n- **500**: Internal server error\n\n**Use Cases:**\n- Retrieve record data and metadata\n- Verify record existence and state\n- Access record content and schema information"
						},
						"response": []
						}
					]
				},
				{
					"name": "query",
					"item": [
						{
							"name": "namespace query (registries)",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üîê ACCESS SECTION - NAMESPACE QUERY",
											"// Authentication is handled automatically by the global collection script",
											"",
											"// Ensure namespace variable is set for testing",
											"if (!pm.collectionVariables.get('namespace')) {",
											"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
											"    pm.collectionVariables.set('namespace', 'test-namespace');",
											"}"
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üß™ NAMESPACE QUERY VALIDATION",
											"pm.test(\"‚úÖ Status code is valid\", function () {",
											"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
											"});",
											"",
											"const responseJson = pm.response.json();",
											"pm.test(\"üìÑ Response has required structure\", function () {",
											"    pm.expect(responseJson).to.have.property('message');",
											"    if (pm.response.code === 200) {",
											"        pm.expect(responseJson).to.have.property('data');",
											"    }",
											"});",
											"",
											"// ‚úÖ SUCCESS CASE (200)",
											"if (pm.response.code === 200) {",
											"    pm.test(\"üéØ Success message is correct\", function () {",
											"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
											"    });",
											"    ",
											"    const data = responseJson.data;",
											"    pm.test(\"üóÇÔ∏è Data has required namespace query fields\", function () {",
											"        pm.expect(data).to.have.property('namespace_id');",
											"        pm.expect(data).to.have.property('namespace_name');",
											"        pm.expect(data).to.have.property('created_by');",
											"        pm.expect(data).to.have.property('created_at');",
											"        pm.expect(data).to.have.property('updated_at');",
											"        pm.expect(data).to.have.property('total_registries');",
											"        pm.expect(data).to.have.property('registries');",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Data types are correct\", function () {",
											"        pm.expect(typeof data.namespace_id).to.equal('string');",
											"        pm.expect(typeof data.namespace_name).to.equal('string');",
											"        pm.expect(typeof data.created_by).to.equal('string');",
											"        pm.expect(typeof data.total_registries).to.equal('number');",
											"        pm.expect(Array.isArray(data.registries)).to.be.true;",
											"    });",
											"    ",
											"    // Validate registry structure if present",
											"    if (data.registries && data.registries.length > 0) {",
											"        pm.test(\"üìã Registry items have correct structure\", function () {",
											"            const registry = data.registries[0];",
											"            pm.expect(registry).to.have.property('registry_id');",
											"            pm.expect(registry).to.have.property('registry_name');",
											"            pm.expect(registry).to.have.property('description');",
											"            pm.expect(registry).to.have.property('created_at');",
											"            pm.expect(registry).to.have.property('updated_at');",
											"            pm.expect(registry).to.have.property('version_count');",
											"        });",
											"    }",
											"    ",
											"    // Store for chaining",
											"    pm.collectionVariables.set('namespace_id', data.namespace_id);",
											"    pm.collectionVariables.set('total_registries', data.total_registries);",
											"    console.log('‚úÖ Namespace query successful:', data.total_registries, 'registries found');",
											"}",
											"",
											"// ‚ùå ERROR CASES",
											"else if (pm.response.code === 404) {",
											"    pm.test(\"üîç Not found error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('namespace not found');",
											"    });",
											"}",
											"else if (pm.response.code === 401) {",
											"    pm.test(\"üîí Unauthorized error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Unauthorized');",
											"    });",
											"}",
											"else if (pm.response.code === 500) {",
											"    pm.test(\"üí• Server error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
											"    });",
											"}"
										]
									}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{url}}/dedi/query/{{namespace}}",
									"host": ["{{url}}"],
									"path": ["dedi", "query", "{{namespace}}"],
									"query": [
										{ 
											"key": "from", 
											"value": "", 
											"description": "Filter from date (YYYY-MM-DD format, optional)",
											"disabled": true 
										},
										{ 
											"key": "to", 
											"value": "", 
											"description": "Filter to date (YYYY-MM-DD format, optional)",
											"disabled": true 
										},
										{ 
											"key": "status", 
											"value": "", 
											"description": "Filter by status: revoked, suspended (optional)",
											"disabled": true 
										},
										{ 
											"key": "name", 
											"value": "", 
											"description": "Search by registry name (optional)",
											"disabled": true 
										},
										{ 
											"key": "sort", 
											"value": "", 
											"description": "Sort by: date, status, name (optional)",
											"disabled": true 
										},
										{ 
											"key": "page", 
											"value": "", 
											"description": "Page number for pagination (optional)",
											"disabled": true 
										},
										{ 
											"key": "page_size", 
											"value": "", 
											"description": "Items per page (optional)",
											"disabled": true 
										},
										{ 
											"key": "as_on", 
											"value": "", 
											"description": "Historical query date (YYYY-MM-DD format, optional)",
											"disabled": true 
										}
									]
								},
								"description": "üîç NAMESPACE QUERY (GET REGISTRIES)\n\nQuery all registries within a namespace with filtering and pagination support.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain to query\n\n**Query Parameters (Optional):**\n- `from`: Filter registries updated from date (YYYY-MM-DD)\n- `to`: Filter registries updated to date (YYYY-MM-DD)\n- `status`: Filter by status (`revoked`, `suspended`)\n- `name`: Search by registry name (minimum 3 characters)\n- `sort`: Sort results (`date`, `status`, `name`)\n- `page`: Page number for pagination\n- `page_size`: Items per page\n- `as_on`: Historical query date (YYYY-MM-DD)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"namespace_id\": \"ns_123...\",\n    \"namespace_name\": \"namespace-name\",\n    \"domain\": \"example.com\",\n    \"created_by\": \"profile_id\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"total_registries\": 25,\n    \"page_number\": 1,\n    \"page_size\": 10,\n    \"registries\": [\n      {\n        \"registry_id\": \"reg_456...\",\n        \"registry_name\": \"registry-name\",\n        \"description\": \"Registry description\",\n        \"created_at\": \"2024-01-01T00:00:00Z\",\n        \"updated_at\": \"2024-01-01T00:00:00Z\",\n        \"version_count\": 3,\n        \"state\": \"live\"\n      }\n    ]\n  }\n}\n```\n\n**Error Cases:**\n- **404**: Namespace not found\n- **401**: Unauthorized (invalid token)\n- **500**: Internal server error\n\n**Use Cases:**\n- List all registries in a namespace\n- Search and filter registries\n- Paginate through large registry collections\n- Monitor registry status and activity"
							},
							"response": []
						},
						{
							"name": "registry query (records)",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üîê ACCESS SECTION - REGISTRY QUERY",
											"// Authentication is handled automatically by the global collection script",
											"",
											"// Ensure namespace and registry variables are set for testing",
											"if (!pm.collectionVariables.get('namespace')) {",
											"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
											"    pm.collectionVariables.set('namespace', 'test-namespace');",
											"}",
											"if (!pm.collectionVariables.get('registry_name')) {",
											"    console.log('‚ö†Ô∏è Warning: registry_name variable not set');",
											"    pm.collectionVariables.set('registry_name', 'test-registry');",
											"}"
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üß™ REGISTRY QUERY VALIDATION",
											"pm.test(\"‚úÖ Status code is valid\", function () {",
											"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
											"});",
											"",
											"const responseJson = pm.response.json();",
											"pm.test(\"üìÑ Response has required structure\", function () {",
											"    pm.expect(responseJson).to.have.property('message');",
											"    if (pm.response.code === 200) {",
											"        pm.expect(responseJson).to.have.property('data');",
											"    }",
											"});",
											"",
											"// ‚úÖ SUCCESS CASE (200)",
											"if (pm.response.code === 200) {",
											"    pm.test(\"üéØ Success message is correct\", function () {",
											"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
											"    });",
											"    ",
											"    const data = responseJson.data;",
											"    pm.test(\"üóÇÔ∏è Data has required registry query fields\", function () {",
											"        pm.expect(data).to.have.property('namespace_id');",
											"        pm.expect(data).to.have.property('namespace_name');",
											"        pm.expect(data).to.have.property('registry_id');",
											"        pm.expect(data).to.have.property('registry_name');",
											"        pm.expect(data).to.have.property('created_by');",
											"        pm.expect(data).to.have.property('created_at');",
											"        pm.expect(data).to.have.property('updated_at');",
											"        pm.expect(data).to.have.property('total_records');",
											"        pm.expect(data).to.have.property('records');",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Data types are correct\", function () {",
											"        pm.expect(typeof data.namespace_id).to.equal('string');",
											"        pm.expect(typeof data.namespace_name).to.equal('string');",
											"        pm.expect(typeof data.registry_id).to.equal('string');",
											"        pm.expect(typeof data.registry_name).to.equal('string');",
											"        pm.expect(typeof data.created_by).to.equal('string');",
											"        pm.expect(typeof data.total_records).to.equal('number');",
											"        pm.expect(Array.isArray(data.records)).to.be.true;",
											"    });",
											"    ",
											"    // Validate record structure if present",
											"    if (data.records && data.records.length > 0) {",
											"        pm.test(\"üìã Record items have correct structure\", function () {",
											"            const record = data.records[0];",
											"            pm.expect(record).to.have.property('record_id');",
											"            pm.expect(record).to.have.property('record_name');",
											"            pm.expect(record).to.have.property('digest');",
											"            pm.expect(record).to.have.property('description');",
											"            pm.expect(record).to.have.property('created_at');",
											"            pm.expect(record).to.have.property('updated_at');",
											"            pm.expect(record).to.have.property('state');",
											"        });",
											"    }",
											"    ",
											"    // Store for chaining",
											"    pm.collectionVariables.set('registry_id', data.registry_id);",
											"    pm.collectionVariables.set('total_records', data.total_records);",
											"    console.log('‚úÖ Registry query successful:', data.total_records, 'records found');",
											"}",
											"",
											"// ‚ùå ERROR CASES",
											"else if (pm.response.code === 404) {",
											"    pm.test(\"üîç Not found error message\", function () {",
											"        pm.expect(responseJson.message).to.be.oneOf(['Registry not found', 'Namespace not found']);",
											"    });",
											"}",
											"else if (pm.response.code === 401) {",
											"    pm.test(\"üîí Unauthorized error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Unauthorized');",
											"    });",
											"}",
											"else if (pm.response.code === 500) {",
											"    pm.test(\"üí• Server error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
											"    });",
											"}"
										]
									}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{url}}/dedi/query/{{namespace}}/{{registry_name}}",
									"host": ["{{url}}"],
									"path": ["dedi", "query", "{{namespace}}", "{{registry_name}}"],
									"query": [
										{ 
											"key": "from", 
											"value": "", 
											"description": "Filter from date (YYYY-MM-DD format, optional)",
											"disabled": true 
										},
										{ 
											"key": "to", 
											"value": "", 
											"description": "Filter to date (YYYY-MM-DD format, optional)",
											"disabled": true 
										},
										{ 
											"key": "state", 
											"value": "", 
											"description": "Filter by state: revoked, suspended, expired (optional)",
											"disabled": true 
										},
										{ 
											"key": "name", 
											"value": "", 
											"description": "Search by record name (optional)",
											"disabled": true 
										},
										{ 
											"key": "sort", 
											"value": "", 
											"description": "Sort by: date, state, name (optional)",
											"disabled": true 
										},
										{ 
											"key": "page", 
											"value": "", 
											"description": "Page number for pagination (optional)",
											"disabled": true 
										},
										{ 
											"key": "page_size", 
											"value": "", 
											"description": "Items per page (optional)",
											"disabled": true 
										},
										{ 
											"key": "as_on", 
											"value": "", 
											"description": "Historical query date (YYYY-MM-DD format, optional)",
											"disabled": true 
										}
									]
								},
								"description": "üîç REGISTRY QUERY (GET RECORDS)\n\nQuery all records within a registry with filtering and pagination support.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain containing the registry\n- `registry_name`: Registry ID or name to query\n\n**Query Parameters (Optional):**\n- `from`: Filter records updated from date (YYYY-MM-DD)\n- `to`: Filter records updated to date (YYYY-MM-DD)\n- `state`: Filter by state (`revoked`, `suspended`, `expired`)\n- `name`: Search by record name (minimum 3 characters)\n- `sort`: Sort results (`date`, `state`, `name`)\n- `page`: Page number for pagination\n- `page_size`: Items per page\n- `as_on`: Historical query date (YYYY-MM-DD)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"namespace_id\": \"ns_123...\",\n    \"namespace_name\": \"namespace-name\",\n    \"registry_id\": \"reg_456...\",\n    \"registry_name\": \"registry-name\",\n    \"created_by\": \"profile_id\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"total_records\": 50,\n    \"page_number\": 1,\n    \"page_size\": 10,\n    \"records\": [\n      {\n        \"record_id\": \"rec_789...\",\n        \"record_name\": \"record-name\",\n        \"digest\": \"sha256:abc123...\",\n        \"description\": \"Record description\",\n        \"created_at\": \"2024-01-01T00:00:00Z\",\n        \"updated_at\": \"2024-01-01T00:00:00Z\",\n        \"state\": \"live\",\n        \"ttl\": 86400\n      }\n    ]\n  }\n}\n```\n\n**Error Cases:**\n- **404**: Registry not found or namespace not found\n- **401**: Unauthorized (invalid token)\n- **500**: Internal server error\n\n**Use Cases:**\n- List all records in a registry\n- Search and filter records by state or name\n- Paginate through large record collections\n- Monitor record activity and expiration"
							},
							"response": []
						}
					]
				},
				{
					"name": "version",
					"item": [
						{
							"name": "namespace version list",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üîê ACCESS SECTION - NAMESPACE VERSIONS",
											"// Authentication is handled automatically by the global collection script",
											"",
											"// Ensure namespace variable is set for testing",
											"if (!pm.collectionVariables.get('namespace')) {",
											"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
											"    pm.collectionVariables.set('namespace', 'test-namespace');",
											"}"
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üß™ NAMESPACE VERSION LIST VALIDATION",
											"pm.test(\"‚úÖ Status code is valid\", function () {",
											"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
											"});",
											"",
											"const responseJson = pm.response.json();",
											"pm.test(\"üìÑ Response has required structure\", function () {",
											"    pm.expect(responseJson).to.have.property('message');",
											"    if (pm.response.code === 200) {",
											"        pm.expect(responseJson).to.have.property('data');",
											"    }",
											"});",
											"",
											"// ‚úÖ SUCCESS CASE (200)",
											"if (pm.response.code === 200) {",
											"    pm.test(\"üéØ Success message is correct\", function () {",
											"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
											"    });",
											"    ",
											"    const data = responseJson.data;",
											"    pm.test(\"üóÇÔ∏è Data has required version fields\", function () {",
											"        pm.expect(data).to.have.property('created_by');",
											"        pm.expect(data).to.have.property('created_at');",
											"        pm.expect(data).to.have.property('updated_at');",
											"        pm.expect(data).to.have.property('total_versions');",
											"        pm.expect(data).to.have.property('versions');",
											"        pm.expect(data).to.have.property('ttl');",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Data types are correct\", function () {",
											"        pm.expect(typeof data.created_by).to.equal('string');",
											"        pm.expect(typeof data.total_versions).to.equal('number');",
											"        pm.expect(typeof data.ttl).to.equal('number');",
											"        pm.expect(Array.isArray(data.versions)).to.be.true;",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Version count consistency\", function () {",
											"        pm.expect(data.versions.length).to.be.at.most(data.total_versions);",
											"    });",
											"    ",
											"    // Validate version format if present",
											"    if (data.versions && data.versions.length > 0) {",
											"        pm.test(\"üìã Version items are strings\", function () {",
											"            data.versions.forEach(version => {",
											"                pm.expect(typeof version).to.equal('string');",
											"            });",
											"        });",
											"    }",
											"    ",
											"    // Store for chaining",
											"    pm.collectionVariables.set('namespace_total_versions', data.total_versions);",
											"    pm.collectionVariables.set('namespace_ttl', data.ttl);",
											"    console.log('‚úÖ Namespace versions:', data.total_versions, 'total versions');",
											"}",
											"",
											"// ‚ùå ERROR CASES",
											"else if (pm.response.code === 404) {",
											"    pm.test(\"üîç Not found error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('namespace not found');",
											"    });",
											"}",
											"else if (pm.response.code === 400) {",
											"    pm.test(\"üìù Bad request error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Invalid input: namespace is missing');",
											"    });",
											"}",
											"else if (pm.response.code === 401) {",
											"    pm.test(\"üîí Unauthorized error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Unauthorized');",
											"    });",
											"}",
											"else if (pm.response.code === 500) {",
											"    pm.test(\"üí• Server error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
											"    });",
											"}"
										]
									}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{url}}/dedi/versions/{{namespace}}",
									"host": ["{{url}}"],
									"path": ["dedi", "versions", "{{namespace}}"]
								},
								"description": "üìã NAMESPACE VERSION LIST\n\nRetrieve all available versions for a specific namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain to get versions for\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"created_by\": \"profile_id\",\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"total_versions\": 5,\n    \"versions\": [\n      \"v1.2.3\",\n      \"v1.2.2\",\n      \"v1.2.1\",\n      \"v1.2.0\",\n      \"v1.1.0\"\n    ],\n    \"ttl\": 86400\n  }\n}\n```\n\n**Error Cases:**\n- **404**: Namespace not found\n- **400**: Invalid input (namespace missing)\n- **401**: Unauthorized (invalid token)\n- **500**: Internal server error\n\n**Use Cases:**\n- Browse namespace version history\n- Track namespace evolution over time\n- Select specific version for historical lookups\n- Audit namespace changes and updates"
							},
							"response": []
						},
						{
							"name": "registry version list",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üîê ACCESS SECTION - REGISTRY VERSIONS",
											"// Authentication is handled automatically by the global collection script",
											"",
											"// Ensure namespace and registry variables are set for testing",
											"if (!pm.collectionVariables.get('namespace')) {",
											"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
											"    pm.collectionVariables.set('namespace', 'test-namespace');",
											"}",
											"if (!pm.collectionVariables.get('registry_name')) {",
											"    console.log('‚ö†Ô∏è Warning: registry_name variable not set');",
											"    pm.collectionVariables.set('registry_name', 'test-registry');",
											"}"
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üß™ REGISTRY VERSION LIST VALIDATION",
											"pm.test(\"‚úÖ Status code is valid\", function () {",
											"    pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
											"});",
											"",
											"const responseJson = pm.response.json();",
											"pm.test(\"üìÑ Response has required structure\", function () {",
											"    pm.expect(responseJson).to.have.property('message');",
											"    if (pm.response.code === 200) {",
											"        pm.expect(responseJson).to.have.property('data');",
											"    }",
											"});",
											"",
											"// ‚úÖ SUCCESS CASE (200)",
											"if (pm.response.code === 200) {",
											"    pm.test(\"üéØ Success message is correct\", function () {",
											"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
											"    });",
											"    ",
											"    const data = responseJson.data;",
											"    pm.test(\"üóÇÔ∏è Data has required registry version fields\", function () {",
											"        pm.expect(data).to.have.property('registry_name');",
											"        pm.expect(data).to.have.property('created_by');",
											"        pm.expect(data).to.have.property('schema');",
											"        pm.expect(data).to.have.property('created_at');",
											"        pm.expect(data).to.have.property('updated_at');",
											"        pm.expect(data).to.have.property('total_versions');",
											"        pm.expect(data).to.have.property('versions');",
											"        pm.expect(data).to.have.property('ttl');",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Data types are correct\", function () {",
											"        pm.expect(typeof data.registry_name).to.equal('string');",
											"        pm.expect(typeof data.created_by).to.equal('string');",
											"        pm.expect(typeof data.total_versions).to.equal('number');",
											"        pm.expect(typeof data.ttl).to.equal('number');",
											"        pm.expect(Array.isArray(data.versions)).to.be.true;",
											"        pm.expect(typeof data.schema).to.be.oneOf(['object', 'string']);",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Version count consistency\", function () {",
											"        pm.expect(data.versions.length).to.be.at.most(data.total_versions);",
											"    });",
											"    ",
											"    // Validate version format if present",
											"    if (data.versions && data.versions.length > 0) {",
											"        pm.test(\"üìã Version items are strings\", function () {",
											"            data.versions.forEach(version => {",
											"                pm.expect(typeof version).to.equal('string');",
											"            });",
											"        });",
											"    }",
											"    ",
											"    // Store for chaining",
											"    pm.collectionVariables.set('registry_total_versions', data.total_versions);",
											"    pm.collectionVariables.set('registry_ttl', data.ttl);",
											"    console.log('‚úÖ Registry versions:', data.total_versions, 'total versions for', data.registry_name);",
											"}",
											"",
											"// ‚ùå ERROR CASES",
											"else if (pm.response.code === 400) {",
											"    pm.test(\"üìù Bad request error message\", function () {",
											"        pm.expect(responseJson.message).to.be.oneOf([",
											"            'Invalid input: namespace is missing',",
											"            'Invalid input: registry_name is missing',",
											"            'namespace not found',",
											"            'registry not found'",
											"        ]);",
											"    });",
											"}",
											"else if (pm.response.code === 401) {",
											"    pm.test(\"üîí Unauthorized error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Unauthorized');",
											"    });",
											"}",
											"else if (pm.response.code === 500) {",
											"    pm.test(\"üí• Server error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
											"    });",
											"}"
										]
									}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{url}}/dedi/versions/{{namespace}}/{{registry_name}}",
									"host": ["{{url}}"],
									"path": ["dedi", "versions", "{{namespace}}", "{{registry_name}}"]
								},
								"description": "üìã REGISTRY VERSION LIST\n\nRetrieve all available versions for a specific registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain containing the registry\n- `registry_name`: Registry name to get versions for\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"registry_name\": \"registry-name\",\n    \"created_by\": \"profile_id\",\n    \"schema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"field1\": { \"type\": \"string\" }\n      }\n    },\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"total_versions\": 3,\n    \"versions\": [\n      \"v1.2.1\",\n      \"v1.2.0\",\n      \"v1.1.0\"\n    ],\n    \"ttl\": 86400\n  }\n}\n```\n\n**Error Cases:**\n- **400**: Invalid input (namespace/registry missing) or not found\n- **401**: Unauthorized (invalid token)\n- **500**: Internal server error\n\n**Use Cases:**\n- Browse registry version history\n- Track schema evolution over time\n- Select specific version for historical lookups\n- Audit registry changes and schema updates"
							},
							"response": []
						},
						{
							"name": "record version list",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üîê ACCESS SECTION - RECORD VERSIONS",
											"// Authentication is handled automatically by the global collection script",
											"",
											"// Ensure namespace, registry and record variables are set for testing",
											"if (!pm.collectionVariables.get('namespace')) {",
											"    console.log('‚ö†Ô∏è Warning: namespace variable not set');",
											"    pm.collectionVariables.set('namespace', 'test-namespace');",
											"}",
											"if (!pm.collectionVariables.get('registry_name')) {",
											"    console.log('‚ö†Ô∏è Warning: registry_name variable not set');",
											"    pm.collectionVariables.set('registry_name', 'test-registry');",
											"}",
											"if (!pm.collectionVariables.get('record_name')) {",
											"    console.log('‚ö†Ô∏è Warning: record_name variable not set');",
											"    pm.collectionVariables.set('record_name', 'test-record');",
											"}"
										]
									}
								},
								{
									"listen": "test",
									"script": {
										"type": "text/javascript",
										"exec": [
											"// üß™ RECORD VERSION LIST VALIDATION",
											"pm.test(\"‚úÖ Status code is valid\", function () {",
											"    pm.expect([200, 400, 401, 500]).to.include(pm.response.code);",
											"});",
											"",
											"const responseJson = pm.response.json();",
											"pm.test(\"üìÑ Response has required structure\", function () {",
											"    pm.expect(responseJson).to.have.property('message');",
											"    if (pm.response.code === 200) {",
											"        pm.expect(responseJson).to.have.property('data');",
											"    }",
											"});",
											"",
											"// ‚úÖ SUCCESS CASE (200)",
											"if (pm.response.code === 200) {",
											"    pm.test(\"üéØ Success message is correct\", function () {",
											"        pm.expect(responseJson.message).to.equal('Resource retrieved successfully');",
											"    });",
											"    ",
											"    const data = responseJson.data;",
											"    pm.test(\"üóÇÔ∏è Data has required record version fields\", function () {",
											"        pm.expect(data).to.have.property('created_by');",
											"        pm.expect(data).to.have.property('schema');",
											"        pm.expect(data).to.have.property('created_at');",
											"        pm.expect(data).to.have.property('updated_at');",
											"        pm.expect(data).to.have.property('total_versions');",
											"        pm.expect(data).to.have.property('versions');",
											"        pm.expect(data).to.have.property('ttl');",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Data types are correct\", function () {",
											"        pm.expect(typeof data.created_by).to.equal('string');",
											"        pm.expect(typeof data.total_versions).to.equal('number');",
											"        pm.expect(typeof data.ttl).to.equal('number');",
											"        pm.expect(Array.isArray(data.versions)).to.be.true;",
											"        pm.expect(typeof data.schema).to.be.oneOf(['object', 'string']);",
											"    });",
											"    ",
											"    pm.test(\"üî¢ Version count consistency\", function () {",
											"        pm.expect(data.versions.length).to.be.at.most(data.total_versions);",
											"    });",
											"    ",
											"    // Validate version format if present",
											"    if (data.versions && data.versions.length > 0) {",
											"        pm.test(\"üìã Version items are strings\", function () {",
											"            data.versions.forEach(version => {",
											"                pm.expect(typeof version).to.equal('string');",
											"            });",
											"        });",
											"    }",
											"    ",
											"    // Store for chaining",
											"    pm.collectionVariables.set('record_total_versions', data.total_versions);",
											"    pm.collectionVariables.set('record_ttl', data.ttl);",
											"    console.log('‚úÖ Record versions:', data.total_versions, 'total versions');",
											"}",
											"",
											"// ‚ùå ERROR CASES",
											"else if (pm.response.code === 400) {",
											"    pm.test(\"üìù Bad request error message\", function () {",
											"        pm.expect(responseJson.message).to.be.oneOf([",
											"            'Invalid input: namespace is missing',",
											"            'Invalid input: registry_name is missing',",
											"            'Invalid input: record_name is missing',",
											"            'namespace not found',",
											"            'registry not found',",
											"            'record not found'",
											"        ]);",
											"    });",
											"}",
											"else if (pm.response.code === 401) {",
											"    pm.test(\"üîí Unauthorized error message\", function () {",
											"        pm.expect(responseJson.message).to.include('Unauthorized');",
											"    });",
											"}",
											"else if (pm.response.code === 500) {",
											"    pm.test(\"üí• Server error message\", function () {",
											"        pm.expect(responseJson.message).to.equal('An unexpected error occurred');",
											"    });",
											"}"
										]
									}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{url}}/dedi/versions/{{namespace}}/{{registry_name}}/{{record_name}}",
									"host": ["{{url}}"],
									"path": ["dedi", "versions", "{{namespace}}", "{{registry_name}}", "{{record_name}}"]
								},
								"description": "üìã RECORD VERSION LIST\n\nRetrieve all available versions for a specific record.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain containing the registry\n- `registry_name`: Registry name containing the record\n- `record_name`: Record name to get versions for\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Resource retrieved successfully\",\n  \"data\": {\n    \"created_by\": \"profile_id\",\n    \"schema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"field1\": { \"type\": \"string\" },\n        \"field2\": { \"type\": \"number\" }\n      }\n    },\n    \"created_at\": \"2024-01-01T00:00:00Z\",\n    \"updated_at\": \"2024-01-01T00:00:00Z\",\n    \"total_versions\": 4,\n    \"versions\": [\n      \"v2.1.0\",\n      \"v2.0.1\",\n      \"v2.0.0\",\n      \"v1.0.0\"\n    ],\n    \"ttl\": 86400\n  }\n}\n```\n\n**Error Cases:**\n- **400**: Invalid input (namespace/registry/record missing) or not found\n- **401**: Unauthorized (invalid token)\n- **500**: Internal server error\n\n**Use Cases:**\n- Browse record version history\n- Track record data evolution over time\n- Select specific version for historical lookups\n- Audit record changes and updates\n- Rollback to previous record versions"
							},
							"response": []
						},
						{
							"name": "get namespace by profile",
							"event": [
								{
								"listen": "prerequest",
								"script": {
									"type": "text/javascript",
									"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script"
									]
								}
								},
								{
								"listen": "test",
								"script": {
									"type": "text/javascript",
									"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has namespaces data\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'namespaces for user profile');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
									]
								}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
								"raw": "{{url}}/dedi/get-namespace-by-profile",
								"host": ["{{url}}"],
								"path": ["dedi", "get-namespace-by-profile"]
								},
								"description": "üë§ GET NAMESPACES BY PROFILE\n\nRetrieve all namespaces created by the authenticated user.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Namespaces retrieved successfully\",\n  \"data\": [\n    {\n      \"namespace_id\": \"ns_123...\",\n      \"name\": \"namespace-name\",\n      \"description\": \"Namespace description\",\n      \"domain\": \"example.com\",\n      \"is_verified\": true,\n      \"created_at\": \"2024-01-01T00:00:00Z\",\n      \"updated_at\": \"2024-01-01T00:00:00Z\",\n      \"registry_count\": 5\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- List user's owned namespaces\n- Namespace management dashboard\n- User profile namespace overview"
							},
							"response": []
						},
						{
							"name": "get registry by profile",
							"event": [
								{
								"listen": "prerequest",
								"script": {
									"type": "text/javascript",
									"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}"
									]
								}
								},
								{
								"listen": "test",
								"script": {
									"type": "text/javascript",
									"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has registries data\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'registries for user profile');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
									]
								}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
								"raw": "{{url}}/dedi/{{namespace}}/get-registry-by-profile",
								"host": ["{{url}}"],
								"path": ["dedi", "{{namespace}}", "get-registry-by-profile"]
								},
								"description": "üë§ GET REGISTRIES BY PROFILE\n\nRetrieve all registries created by the authenticated user in a specific namespace.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Registries retrieved successfully\",\n  \"data\": [\n    {\n      \"registry_id\": \"reg_456...\",\n      \"registry_name\": \"registry-name\",\n      \"description\": \"Registry description\",\n      \"schema\": {},\n      \"record_count\": 25,\n      \"created_at\": \"2024-01-01T00:00:00Z\",\n      \"updated_at\": \"2024-01-01T00:00:00Z\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- List user's owned registries in namespace\n- Registry management dashboard\n- User profile registry overview"
							},
							"response": []
						},
						{
							"name": "get registry by schema tag",
							"event": [
								{
								"listen": "prerequest",
								"script": {
									"type": "text/javascript",
									"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('schema_tag')) {",
									"  pm.collectionVariables.set('schema_tag', 'membership');",
									"}"
									]
								}
								},
								{
								"listen": "test",
								"script": {
									"type": "text/javascript",
									"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has registries data\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'registries with schema tag');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
									]
								}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
								"raw": "{{url}}/dedi/{{schema_tag}}/get-registry-by-tag",
								"host": ["{{url}}"],
								"path": ["dedi", "{{schema_tag}}", "get-registry-by-tag"]
								},
								"description": "üè∑Ô∏è GET REGISTRIES BY SCHEMA TAG\n\nQuery registries by their schema tag (e.g., 'membership', 'public_key', 'custom').\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `tag`: Schema tag to filter by (membership, public_key, revoke, custom)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Registries retrieved successfully\",\n  \"data\": [\n    {\n      \"registry_id\": \"reg_456...\",\n      \"registry_name\": \"registry-name\",\n      \"namespace_id\": \"ns_123...\",\n      \"description\": \"Registry description\",\n      \"tag\": \"membership\",\n      \"schema\": {},\n      \"created_at\": \"2024-01-01T00:00:00Z\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- Find registries by schema type\n- Discovery of compatible registries\n- Schema standardization queries"
							},
							"response": []
						},
						{
							"name": "get records by profile",
							"event": [
								{
								"listen": "prerequest",
								"script": {
									"type": "text/javascript",
									"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}",
									"if (!pm.collectionVariables.get('registry_name')) {",
									"  pm.collectionVariables.set('registry_name', 'test-registry');",
									"}"
									]
								}
								},
								{
								"listen": "test",
								"script": {
									"type": "text/javascript",
									"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has records data\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'records for user profile');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
									]
								}
								}
							],
							"request": {
								"auth": { "type": "noauth" },
								"method": "GET",
								"header": [],
								"url": {
								"raw": "{{url}}/dedi/internal/{{namespace}}/{{registry_name}}/query-records-by-profile",
								"host": ["{{url}}"],
								"path": ["dedi", "internal", "{{namespace}}", "{{registry_name}}", "query-records-by-profile"]
								},
								"description": "üë§ GET RECORDS BY PROFILE\n\nRetrieve all records created by the authenticated user in a specific registry.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Records retrieved successfully\",\n  \"data\": [\n    {\n      \"record_id\": \"rec_789...\",\n      \"record_name\": \"record-name\",\n      \"description\": \"Record description\",\n      \"details\": {},\n      \"state\": \"live\",\n      \"created_at\": \"2024-01-01T00:00:00Z\",\n      \"updated_at\": \"2024-01-01T00:00:00Z\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- List user's owned records in registry\n- Record management dashboard\n- User profile record overview"
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Verification & Lookup",
			"item": [
				{
					"name": "verify namespace lookup",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Verification successful\", function () {",
									"    pm.expect(res).to.have.property('message');",
									"    pm.expect(res.message).to.include('verified');",
									"  });",
									"  console.log('‚úÖ Namespace lookup verified successfully');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"namespace_lookup_response\": \"{{Paste response from namespace lookup here}}\"\n}",
							"options": { "raw": { "language": "json" } }
						},
						"url": {
							"raw": "{{url}}/dedi/verify-namespace-lookup",
							"host": ["{{url}}"],
							"path": ["dedi", "verify-namespace-lookup"]
						},
						"description": "üîç VERIFY NAMESPACE LOOKUP\n\nVerify the authenticity and integrity of a namespace lookup result.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"namespace_id\": \"ns_123...\",\n  \"digest\": \"0x456...\"\n}\n```\n\n**Use Cases:**\n- Verify namespace data integrity\n- Authenticate namespace lookups\n- Validate namespace existence"
					},
					"response": []
				},
				{
					"name": "verify registry lookup",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}",
									"if (!pm.collectionVariables.get('registry_name')) {",
									"  pm.collectionVariables.set('registry_name', 'test-registry');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Verification successful\", function () {",
									"    pm.expect(res).to.have.property('message');",
									"    pm.expect(res.message).to.include('verified');",
									"  });",
									"  console.log('‚úÖ Registry lookup verified successfully');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"registry_lookup_response\": \"{{Paste response from registry lookup here}}\"\n}",
							"options": { "raw": { "language": "json" } }
						},
						"url": {
							"raw": "{{url}}/dedi/verify-registry-lookup",
							"host": ["{{url}}"],
							"path": ["dedi", "verify-registry-lookup"]
						},
						"description": "üîç VERIFY REGISTRY LOOKUP\n\nVerify the authenticity and integrity of a registry lookup result.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"namespace_id\": \"ns_123...\",\n  \"registry_name\": \"registry-name\",\n  \"digest\": \"0x456...\"\n}\n```\n\n**Use Cases:**\n- Verify registry data integrity\n- Authenticate registry lookups\n- Validate registry existence"
					},
					"response": []
				},
				{
					"name": "verify record lookup",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}",
									"if (!pm.collectionVariables.get('registry_name')) {",
									"  pm.collectionVariables.set('registry_name', 'test-registry');",
									"}",
									"if (!pm.collectionVariables.get('record_name')) {",
									"  pm.collectionVariables.set('record_name', 'test-record');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Verification successful\", function () {",
									"    pm.expect(res).to.have.property('message');",
									"    pm.expect(res.message).to.include('verified');",
									"  });",
									"  console.log('‚úÖ Record lookup verified successfully');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"record_lookup_response\": \"{{Paste response from record lookup here}}\"\n}",
							"options": { "raw": { "language": "json" } }
						},
						"url": {
							"raw": "{{url}}/dedi/verify-record-lookup",
							"host": ["{{url}}"],
							"path": ["dedi", "verify-record-lookup"]
						},
						"description": "üîç VERIFY RECORD LOOKUP\n\nVerify the authenticity and integrity of a record lookup result.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"namespace_id\": \"ns_123...\",\n  \"registry_name\": \"registry-name\",\n  \"record_name\": \"record-name\",\n  \"digest\": \"0x456...\"\n}\n```\n\n**Use Cases:**\n- Verify record data integrity\n- Authenticate record lookups\n- Validate record existence"
					},
					"response": []
				},
				{
					"name": "get namespace verification logs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has verification logs\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'verification logs');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/{{namespace}}/get-namespace-verification-logs",
							"host": ["{{url}}"],
							"path": ["dedi", "{{namespace}}", "get-namespace-verification-logs"]
						},
						"description": "üìã GET NAMESPACE VERIFICATION LOGS\n\nRetrieve audit trail of namespace verification activities.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Verification logs retrieved successfully\",\n  \"data\": [\n    {\n      \"log_id\": \"log_123...\",\n      \"verification_type\": \"lookup\",\n      \"verified_at\": \"2024-01-01T00:00:00Z\",\n      \"verified_by\": \"user_456...\",\n      \"result\": \"success\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- Audit namespace verification activity\n- Track verification history\n- Monitor verification patterns"
					},
					"response": []
				},
				{
					"name": "get registry verification logs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}",
									"if (!pm.collectionVariables.get('registry_name')) {",
									"  pm.collectionVariables.set('registry_name', 'test-registry');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has verification logs\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'verification logs');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/get-registry-verification-logs",
							"host": ["{{url}}"],
							"path": ["dedi", "{{namespace}}", "{{registry_name}}", "get-registry-verification-logs"]
						},
						"description": "üìã GET REGISTRY VERIFICATION LOGS\n\nRetrieve audit trail of registry verification activities.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Verification logs retrieved successfully\",\n  \"data\": [\n    {\n      \"log_id\": \"log_123...\",\n      \"verification_type\": \"lookup\",\n      \"verified_at\": \"2024-01-01T00:00:00Z\",\n      \"verified_by\": \"user_456...\",\n      \"result\": \"success\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- Audit registry verification activity\n- Track verification history\n- Monitor verification patterns"
					},
					"response": []
				},
				{
					"name": "get record verification logs",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"if (!pm.collectionVariables.get('namespace')) {",
									"  pm.collectionVariables.set('namespace', 'test-namespace');",
									"}",
									"if (!pm.collectionVariables.get('registry_name')) {",
									"  pm.collectionVariables.set('registry_name', 'test-registry');",
									"}",
									"if (!pm.collectionVariables.get('record_name')) {",
									"  pm.collectionVariables.set('record_name', 'test-record');",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status code is 200 or error\", function () {",
									"  pm.expect([200, 400, 401, 404, 500]).to.include(pm.response.code);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"  const res = pm.response.json();",
									"  pm.test(\"Response has verification logs\", function () {",
									"    pm.expect(res).to.have.property('data');",
									"    pm.expect(res.data).to.be.an('array');",
									"  });",
									"  console.log('‚úÖ Retrieved', res.data.length, 'verification logs');",
									"} else {",
									"  pm.test(\"Response has error message\", function () {",
									"    pm.expect(pm.response.json()).to.have.property('message');",
									"  });",
									"}"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/{{namespace}}/{{registry_name}}/{{record_name}}/get-record-verification-logs",
							"host": ["{{url}}"],
							"path": ["dedi", "{{namespace}}", "{{registry_name}}", "{{record_name}}", "get-record-verification-logs"]
						},
						"description": "üìã GET RECORD VERIFICATION LOGS\n\nRetrieve audit trail of record verification activities.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain\n- `registry_name`: Registry name\n- `record_name`: Record name\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Verification logs retrieved successfully\",\n  \"data\": [\n    {\n      \"log_id\": \"log_123...\",\n      \"verification_type\": \"lookup\",\n      \"verified_at\": \"2024-01-01T00:00:00Z\",\n      \"verified_by\": \"user_456...\",\n      \"result\": \"success\"\n    }\n  ]\n}\n```\n\n**Use Cases:**\n- Audit record verification activity\n- Track verification history\n- Monitor verification patterns"
					},
					"response": []
				}
			]
		},
		{
			"name": "Advanced Search",
			"item": [
				{
					"name": "üîç Search Records in Namespace",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// ‚úÖ Authentication is handled automatically by the global collection script",
									"",
									"// Set default search parameters if not provided",
									"if (!pm.variables.get(\"namespace\")) {",
									"    pm.variables.set(\"namespace\", \"my-namespace\");",
									"}",
									"",
									"// Example search parameters for testing",
									"if (!pm.variables.get(\"registry_name\")) {",
									"    pm.variables.set(\"registry_name\", \"my-registry\");",
									"}",
									"",
									"// You can add any field from the record's details JSON",
									"pm.variables.set(\"record_name\", \"test-record\");",
									"pm.variables.set(\"email\", \"test@example.com\");",
									"pm.variables.set(\"publicKey\", \"abc123\");",
									"",
									"console.log('üîç Setting up search parameters...');",
									"console.log('üìÅ Namespace:', pm.variables.get('namespace'));",
									"console.log('üìã Registry filter:', pm.variables.get('registry_name'));"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 200, 400, 401, 404, or 500', function () {",
									"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 404, 500]);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// üß™ Test: Success Response Structure",
									"if (pm.response.code === 200) {",
									"    pm.test('‚úÖ Search results retrieved successfully', function () {",
									"        pm.expect(responseJson.message).to.eql('Search results');",
									"        pm.expect(responseJson).to.have.property('data');",
									"        pm.expect(responseJson.data).to.be.an('array');",
									"    });",
									"    ",
									"    pm.test('‚úÖ Search results contain valid record structure', function () {",
									"        if (responseJson.data.length > 0) {",
									"            const firstRecord = responseJson.data[0];",
									"            pm.expect(firstRecord).to.have.property('record_name');",
									"            pm.expect(firstRecord).to.have.property('registry_name');",
									"            pm.expect(firstRecord).to.have.property('namespace_id');",
									"            pm.expect(firstRecord).to.have.property('details');",
									"            pm.expect(firstRecord).to.have.property('created_at');",
									"            pm.expect(firstRecord).to.have.property('updated_at');",
									"        }",
									"    });",
									"    ",
									"    // Log search results for debugging",
									"    console.log('üéØ Search Results Summary:');",
									"    console.log(`üìä Found ${responseJson.data.length} matching records`);",
									"    ",
									"    if (responseJson.data.length > 0) {",
									"        console.log('üìã First few results:');",
									"        responseJson.data.slice(0, 3).forEach((record, index) => {",
									"            console.log(`  ${index + 1}. ${record.record_name} (${record.registry_name})`);",
									"        });",
									"    }",
									"}",
									"",
									"// üß™ Test: Error Response Validation",
									"if (pm.response.code === 400) {",
									"    pm.test('üö® Bad Request - Missing namespace parameter', function () {",
									"        pm.expect(responseJson.message).to.include('namespace is missing');",
									"    });",
									"}",
									"",
									"if (pm.response.code === 401) {",
									"    pm.test('üö® Unauthorized - Authentication required', function () {",
									"        pm.expect(responseJson.message).to.match(/unauthorized|invalid token|authentication/i);",
									"    });",
									"}",
									"",
									"if (pm.response.code === 404) {",
									"    pm.test('üö® Not Found - Namespace does not exist', function () {",
									"        pm.expect(responseJson.message).to.include('namespace not found');",
									"    });",
									"}",
									"",
									"if (pm.response.code === 500) {",
									"    pm.test('üö® Server Error - Query execution failed', function () {",
									"        pm.expect(responseJson.message).to.match(/query failed|database error/i);",
									"    });",
									"}",
									"",
									"// üß™ Test: Response Time Validation",
									"pm.test('‚ö° Response time is acceptable (<3s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(3000);",
									"});",
									"",
									"// üß™ Test: Response Headers",
									"pm.test('‚úÖ Response has correct content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});"
								]
							}
						}
					],
					"request": {
						"auth": { "type": "noauth" },
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/search/{{namespace}}?registry_name={{registry_name}}&record_name={{record_name}}&email={{email}}&publicKey={{publicKey}}",
							"host": ["{{url}}"],
							"path": ["dedi", "search", "{{namespace}}"],
							"query": [
								{
									"key": "registry_name",
									"value": "{{registry_name}}",
									"description": "üîç Filter by registry name (partial match, case-insensitive)"
								},
								{
									"key": "record_name",
									"value": "{{record_name}}",
									"description": "üîç Search by record name (partial match, case-insensitive)"
								},
								{
									"key": "email",
									"value": "{{email}}",
									"description": "üîç Search by email field in record details (nested JSON field support)"
								},
								{
									"key": "publicKey",
									"value": "{{publicKey}}",
									"description": "üîç Search by publicKey field in record details (nested JSON field support)"
								},
								{
									"key": "detail.address",
									"value": "{{address}}",
									"description": "üîç Example: Search nested field using dot notation (detail.address)",
									"disabled": true
								},
								{
									"key": "profile.name",
									"value": "{{profile_name}}",
									"description": "üîç Example: Search deeply nested field (profile.name)",
									"disabled": true
								}
							]
						},
						"description": "üîç ADVANCED RECORD SEARCH\n\nPowerful search functionality across all records in a namespace with support for nested field searching and flexible filtering.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Path Parameters:**\n- `namespace`: Namespace ID or domain to search within\n\n**Query Parameters (ALL OPTIONAL):**\n- `registry_name`: Filter by registry name (partial match)\n- `record_name`: Search by record name (partial match)\n- **Any field from record details:** Search by any field in the record's JSON details\n- **Nested field support:** Use dot notation for nested fields (e.g., `detail.address`, `profile.name`)\n\n**üéØ SEARCH CAPABILITIES:**\n1. **Registry Filtering:** `registry_name=my-registry`\n2. **Record Name Search:** `record_name=test-record`\n3. **Direct Field Search:** `email=user@example.com` (searches in record.details.email)\n4. **Nested Field Search:** `detail.publicKey=abc123` (searches in record.details.detail.publicKey)\n5. **Multiple Criteria:** Combine any parameters for precise filtering\n6. **Partial Matching:** All searches use case-insensitive partial matching (ILIKE)\n\n**üìù FIELD SEARCH EXAMPLES:**\n- Basic fields: `email`, `publicKey`, `phone`, `name`\n- Nested fields: `detail.address`, `profile.name`, `contact.email`\n- Deep nesting: `data.user.profile.settings.theme`\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Search results\",\n  \"data\": [\n    {\n      \"record_id\": \"uuid\",\n      \"record_name\": \"test-record\",\n      \"registry_name\": \"my-registry\",\n      \"namespace_id\": \"my-namespace\",\n      \"description\": \"Test record description\",\n      \"details\": {\n        \"email\": \"user@example.com\",\n        \"publicKey\": \"abc123...\",\n        \"detail\": {\n          \"address\": \"123 Main St\"\n        }\n      },\n      \"state\": \"live\",\n      \"created_at\": \"2024-01-01T00:00:00Z\",\n      \"updated_at\": \"2024-01-15T10:30:00Z\",\n      \"version\": \"v1.2.0\",\n      \"ttl\": 86400\n    }\n  ]\n}\n```\n\n**Error Cases:**\n- **400**: Missing namespace parameter\n- **401**: Unauthorized (invalid or missing token)\n- **404**: Namespace not found\n- **500**: Query failed or database error\n\n**üí° USE CASES:**\n- **User Discovery:** Find records by email, name, or contact info\n- **Registry Browsing:** Filter records within specific registries\n- **Data Mining:** Search across custom fields in JSON details\n- **Compliance:** Locate records with specific attributes\n- **Integration:** API-driven search for external applications\n- **Debugging:** Find test records or problematic entries\n\n**‚ö° PERFORMANCE TIPS:**\n- Use specific field searches rather than broad queries\n- Combine multiple criteria to narrow results\n- Registry filtering significantly improves search performance\n- Nested field searches use PostgreSQL JSON operators for efficiency\n\n**üîê SECURITY:**\n- Only returns records you have permission to view\n- Authentication required for all search operations\n- Search scope limited to authenticated user's accessible data"
					},
					"response": []
				}
			]
		},
		{
			"name": "Watch & Notifications",
			"item": [
				{
					"name": "subscribe",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üëÄ WATCH SUBSCRIPTION - Subscribe to changes",
									"// Monitor namespaces, registries, or records for updates",
									"",
									"console.log('üëÄ Setting up watch subscription...');",
									"console.log('üìã Endpoint: POST /dedi/subscribe');",
									"console.log('üîê Authentication: Required (Cookie or API Key)');",
									"",
									"// Set default values if not provided",
									"const namespace = pm.variables.get('namespace') || 'default-namespace';",
									"const registryName = pm.variables.get('registry_name') || 'default-registry';",
									"const webhookUrl = pm.variables.get('webhook_url') || 'https://your-app.com/webhook/dedi-updates';",
									"const webhookSecret = pm.variables.get('webhook_secret') || 'your-webhook-secret';",
									"",
									"// Validation",
									"if (!namespace) {",
									"    console.warn('‚ö†Ô∏è  Namespace not specified. Using default.');",
									"    pm.variables.set('namespace', 'default-namespace');",
									"}",
									"",
									"if (!registryName) {",
									"    console.warn('‚ö†Ô∏è  Registry name not specified. Using default.');",
									"    pm.variables.set('registry_name', 'default-registry');",
									"}",
									"",
									"if (!webhookUrl) {",
									"    console.warn('‚ö†Ô∏è  Webhook URL not specified. Using default.');",
									"    pm.variables.set('webhook_url', 'https://your-app.com/webhook/dedi-updates');",
									"}",
									"",
									"if (!webhookSecret) {",
									"    console.warn('‚ö†Ô∏è  Webhook secret not specified. Using default.');",
									"    pm.variables.set('webhook_secret', 'your-webhook-secret');",
									"}",
									"",
									"console.log(`üìå Namespace: ${namespace}`);",
									"console.log(`üìå Registry: ${registryName}`);",
									"console.log(`üîó Webhook URL: ${webhookUrl}`);"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ WATCH SUBSCRIPTION TESTS",
									"",
									"// Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 201', function () {",
									"    pm.expect(pm.response.code).to.equal(201);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// Test: Success Response Structure",
									"if (pm.response.code === 201) {",
									"    pm.test('‚úÖ Watch subscription created successfully', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        pm.expect(responseJson.message).to.include('Successfully subscribed to watch');",
									"    });",
									"    ",
									"    // Extract and store subscription details",
									"    if (responseJson.data) {",
									"        pm.test('‚úÖ Subscription data available', function () {",
									"            pm.expect(responseJson.data).to.have.property('id');",
									"            pm.expect(responseJson.data).to.have.property('namespace_id');",
									"            pm.expect(responseJson.data).to.have.property('registry_name');",
									"            pm.expect(responseJson.data).to.have.property('webhook_url');",
									"            pm.expect(responseJson.data).to.have.property('is_active');",
									"            pm.expect(responseJson.data).to.have.property('type');",
									"        });",
									"        ",
									"        // Store subscription ID for future operations",
									"        if (responseJson.data.id) {",
									"            pm.collectionVariables.set('subscription_id', responseJson.data.id);",
									"            console.log('üìå Subscription ID stored:', responseJson.data.id);",
									"        }",
									"    }",
									"    ",
									"    console.log('‚úÖ Watch subscription active');",
									"    console.log('üì¨ Notifications will be sent to webhook URL');",
									"}",
									"",
									"// Test: Error Response Handling",
									"if (pm.response.code >= 400) {",
									"    pm.test('üö® Error response handled properly', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        ",
									"        if (pm.response.code === 400) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('required') || message.includes('invalid') || message.includes('missing');",
									"            });",
									"        }",
									"        ",
									"        if (pm.response.code === 401) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('unauthorized') || message.includes('authentication');",
									"            });",
									"        }",
									"        ",
									"        if (pm.response.code === 404) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('not found') || message.includes('does not exist');",
									"            });",
									"        }",
									"        ",
									"        console.log('üö® Subscription failed:', responseJson.message);",
									"    });",
									"}",
									"",
									"// Test: Response Time",
									"pm.test('‚ö° Response time is acceptable (<3s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(3000);",
									"});",
									"",
									"// Test: Content Type",
									"pm.test('‚úÖ Response has JSON content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Cookie",
								"value": "token={{auth_cookie}}",
								"type": "text",
								"disabled": true
							},
							{
								"key": "Authorization",
								"value": "Bearer {{api_key}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"namespace\": \"{{namespace}}\",\n  \"registry_name\": \"{{registry_name}}\",\n  \"record_name\": \"{{record_name}}\",\n  \"registry_tag\": \"{{registry_tag}}\",\n  \"webhook_url\": \"{{webhook_url}}\",\n  \"webhook_secret\": \"{{webhook_secret}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/dedi/subscribe",
							"host": ["{{url}}"],
							"path": ["dedi", "subscribe"]
						},
						"description": "üëÄ SUBSCRIBE TO WATCH\n\nSubscribe to real-time notifications for changes to namespaces, registries, or records.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"namespace\": \"namespace-id or domain\",\n  \"registry_name\": \"registry-name\",\n  \"record_name\": \"record-name (optional for registry watch)\",\n  \"registry_tag\": \"tag-name (optional, alternative to namespace/registry)\",\n  \"webhook_url\": \"https://your-app.com/webhook/dedi-updates\",\n  \"webhook_secret\": \"your-webhook-secret\"\n}\n```\n\n**Watch Types (automatically determined):**\n- **registry**: When namespace + registry_name provided (without record_name)\n- **record**: When namespace + registry_name + record_name provided  \n- **registry_tag**: When registry_tag provided (watches all registries with this tag)\n\n**Required Fields:**\n- `webhook_url`: HTTPS URL to receive notifications\n- `webhook_secret`: Secret for webhook verification\n- Either (`namespace` + `registry_name`) OR `registry_tag`\n\n**Success Response (201):**\n```json\n{\n  \"message\": \"Successfully subscribed to watch\",\n  \"data\": {\n    \"id\": \"w_abc123-def4-5678-9012-abcdef123456\",\n    \"namespace_id\": \"ns_example\",\n    \"registry_name\": \"my-registry\",\n    \"record_name\": \"my-record\",\n    \"registry_tag\": null,\n    \"type\": \"record\",\n    \"email\": \"user@example.com\",\n    \"webhook_url\": \"https://your-app.com/webhook\",\n    \"is_active\": true,\n    \"created_at\": \"2024-01-01T00:00:00Z\"\n  }\n}\n```\n\n**üí° USE CASES:**\n- **Real-time Updates**: Get instant notifications when data changes\n- **Registry Monitoring**: Track new records added to registries\n- **Record Changes**: Monitor updates to specific records\n- **Tag-based Watching**: Watch all registries with specific tags\n- **Integration Webhooks**: Trigger external system updates\n- **Data Synchronization**: Keep external systems in sync\n\n**üîî WEBHOOK NOTIFICATIONS:**\nYour webhook will receive POST requests when changes occur. The payload structure depends on the change type and includes relevant entity data.\n\n**üìù REQUIREMENTS:**\n- Valid webhook URL (must be HTTPS)\n- Target namespace/registry/record must exist and user must have access\n- Webhook secret for payload verification\n- Valid authentication (cookie or API key)\n\n**‚è∞ SUBSCRIPTION LIFECYCLE:**\n- Subscriptions remain active until manually unsubscribed\n- Use /dedi/unsubscribe to remove subscriptions\n- Use /dedi/subscriptions to list your active subscriptions\n- Expired or invalid subscriptions are cleaned up automatically\n\n**üîê SECURITY:**\n- Webhook deliveries include signature for verification using webhook_secret\n- Only authenticated users can create subscriptions\n- Users can only subscribe to entities they have access to\n- Rate limiting applies to prevent abuse"
					},
					"response": []
				},
				{
					"name": "unsubscribe",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üëÄ WATCH UNSUBSCRIBE - Stop receiving notifications",
									"// Remove existing watch subscription",
									"",
									"console.log('üëÄ Removing watch subscription...');",
									"console.log('üìã Endpoint: POST /dedi/unsubscribe');",
									"console.log('üîê Authentication: Required (Cookie or API Key)');",
									"",
									"// Validation: Check if subscription ID is provided",
									"const subscriptionId = pm.collectionVariables.get('subscription_id');",
									"",
									"if (!subscriptionId) {",
									"    console.warn('‚ö†Ô∏è  No subscription ID found. Please subscribe first or set subscription_id variable.');",
									"} else {",
									"    console.log(`üìå Unsubscribing from: ${subscriptionId}`);",
									"}"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ WATCH UNSUBSCRIBE TESTS",
									"",
									"// Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 200', function () {",
									"    pm.expect(pm.response.code).to.equal(200);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// Test: Success Response Structure",
									"if (pm.response.code === 200) {",
									"    pm.test('‚úÖ Watch unsubscribed successfully', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        pm.expect(responseJson.message).to.include('Successfully unsubscribed');",
									"    });",
									"    ",
									"    // Verify data structure",
									"    if (responseJson.data) {",
									"        pm.test('‚úÖ Unsubscribed data available', function () {",
									"            pm.expect(responseJson.data).to.have.property('id');",
									"            pm.expect(responseJson.data).to.have.property('email');",
									"            pm.expect(responseJson.data).to.have.property('webhook_url');",
									"        });",
									"    }",
									"    ",
									"    console.log('‚úÖ Watch subscription removed');",
									"    console.log('üì™ No more notifications will be sent');",
									"    ",
									"    // Clear stored subscription ID",
									"    pm.collectionVariables.unset('subscription_id');",
									"}",
									"",
									"// Test: Error Response Handling",
									"if (pm.response.code >= 400) {",
									"    pm.test('üö® Error response handled properly', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        ",
									"        if (pm.response.code === 400) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('required') || message.includes('invalid') || message.includes('missing');",
									"            });",
									"        }",
									"        ",
									"        if (pm.response.code === 401) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('unauthorized') || message.includes('authentication');",
									"            });",
									"        }",
									"        ",
									"        if (pm.response.code === 404) {",
									"            pm.expect(responseJson.message).to.satisfy(function(message) {",
									"                return message.includes('not found') || message.includes('No watches found');",
									"            });",
									"        }",
									"        ",
									"        console.log('üö® Unsubscribe failed:', responseJson.message);",
									"    });",
									"}",
									"",
									"// Test: Response Time",
									"pm.test('‚ö° Response time is acceptable (<2s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);",
									"});",
									"",
									"// Test: Content Type",
									"pm.test('‚úÖ Response has JSON content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							},
							{
								"key": "Cookie",
								"value": "token={{auth_cookie}}",
								"type": "text",
								"disabled": true
							},
							{
								"key": "Authorization",
								"value": "Bearer {{api_key}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"id\": \"{{subscription_id}}\"\n}"
						},
						"url": {
							"raw": "{{url}}/dedi/unsubscribe",
							"host": ["{{url}}"],
							"path": ["dedi", "unsubscribe"]
						},
						"description": "üëÄ UNSUBSCRIBE FROM WATCH\n\nRemove an existing watch subscription to stop receiving notifications.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Request Body:**\n```json\n{\n  \"id\": \"w_abc123-def4-5678-9012-abcdef123456\"\n}\n```\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Successfully unsubscribed\",\n  \"data\": {\n    \"id\": \"w_abc123-def4-5678-9012-abcdef123456\",\n    \"namespace_id\": \"ns_example\",\n    \"registry_name\": \"my-registry\",\n    \"record_name\": \"my-record\",\n    \"type\": \"record\",\n    \"email\": \"user@example.com\",\n    \"webhook_url\": \"https://your-app.com/webhook\",\n    \"is_active\": true,\n    \"created_at\": \"2024-01-01T00:00:00Z\"\n  }\n}\n```\n\n**üí° USE CASES:**\n- **Stop Notifications**: Disable unwanted webhook notifications\n- **Subscription Management**: Clean up unused subscriptions\n- **Privacy Control**: Remove monitoring when no longer needed\n- **Resource Cleanup**: Prevent webhook endpoint overload\n- **Testing Cleanup**: Remove test subscriptions\n- **User Preference**: Allow users to manage their notifications\n\n**üìù REQUIREMENTS:**\n- Valid watch ID (starts with 'w_')\n- User must own the subscription\n- Subscription must exist and be active\n\n**üîÑ EFFECTS:**\n- Immediate cessation of webhook deliveries\n- Subscription removed from database\n- No future events will be sent\n- Subscription data returned in response\n\n**Error Cases:**\n- **400**: Missing or invalid subscription ID\n- **401**: Unauthorized (invalid or missing token)\n- **404**: Subscription not found or user doesn't own it\n- **500**: Database error during removal\n\n**üîê SECURITY:**\n- Only subscription owner can unsubscribe\n- Authentication required\n- Subscription isolation per user\n- Complete removal from system"
					},
					"response": []
				},
				{
					"name": "cleanup-expired",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üëÄ WATCH CLEANUP - Remove expired subscriptions",
									"// Admin endpoint to clean up old/expired watch subscriptions",
									"",
									"console.log('üßπ Cleaning up expired watch subscriptions...');",
									"console.log('üìã Endpoint: DELETE /dedi/cleanup-expired');",
									"console.log('üîê Authentication: Not required (system endpoint)');",
									"console.log('‚ö†Ô∏è  This is typically called by system cron jobs');",
									"",
									"// This endpoint is usually called by scheduled tasks",
									"console.log('üïê Removing subscriptions older than 30 days');"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ WATCH CLEANUP TESTS",
									"",
									"// Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 200', function () {",
									"    pm.expect(pm.response.code).to.equal(200);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// Test: Success Response Structure",
									"if (pm.response.code === 200) {",
									"    pm.test('‚úÖ Cleanup operation completed', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        pm.expect(responseJson.message).to.include('cleanup');",
									"    });",
									"    ",
									"    // Check cleanup statistics",
									"    if (responseJson.data) {",
									"        pm.test('‚úÖ Cleanup statistics available', function () {",
									"            pm.expect(responseJson.data).to.have.property('removed_count');",
									"            pm.expect(responseJson.data.removed_count).to.be.a('number');",
									"            pm.expect(responseJson.data.removed_count).to.be.at.least(0);",
									"        });",
									"        ",
									"        const removedCount = responseJson.data.removed_count;",
									"        console.log(`üßπ Cleanup completed: ${removedCount} expired subscriptions removed`);",
									"        ",
									"        if (removedCount > 0) {",
									"            console.log('‚úÖ System maintenance: Expired subscriptions cleaned up');",
									"        } else {",
									"            console.log('‚úÖ No expired subscriptions found');",
									"        }",
									"    }",
									"}",
									"",
									"// Test: Error Response Handling",
									"if (pm.response.code >= 400) {",
									"    pm.test('üö® Error response handled properly', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        console.log('üö® Cleanup failed:', responseJson.message);",
									"    });",
									"}",
									"",
									"// Test: Response Time",
									"pm.test('‚ö° Response time is acceptable (<5s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);",
									"});",
									"",
									"// Test: Content Type",
									"pm.test('‚úÖ Response has JSON content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/cleanup-expired",
							"host": ["{{url}}"],
							"path": ["dedi", "cleanup-expired"]
						},
						"description": "üßπ CLEANUP EXPIRED WATCH SUBSCRIPTIONS\n\nSystem maintenance endpoint to remove expired watch subscriptions and clean up database.\n\n**Authentication:** Not required (system endpoint)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"Expired watch subscriptions cleanup completed\",\n  \"data\": {\n    \"removed_count\": 42,\n    \"cleanup_date\": \"2024-01-15T10:30:00Z\",\n    \"retention_days\": 30\n  }\n}\n```\n\n**üßπ CLEANUP PROCESS:**\n1. **Identify Expired**: Find subscriptions older than retention period (30 days)\n2. **Validation Check**: Ensure subscriptions are truly inactive\n3. **Safe Removal**: Delete subscription records and associated data\n4. **Audit Logging**: Log cleanup operations for monitoring\n5. **Statistics Update**: Return cleanup statistics\n\n**üìä RESPONSE DATA:**\n- **removed_count**: Number of subscriptions cleaned up\n- **cleanup_date**: When the cleanup operation was performed\n- **retention_days**: Retention period used for cleanup (typically 30 days)\n\n**üí° USE CASES:**\n- **Scheduled Maintenance**: Called by cron jobs or scheduled tasks\n- **Database Optimization**: Prevent database bloat from old subscriptions\n- **Resource Management**: Free up system resources\n- **Compliance**: Data retention policy enforcement\n- **Performance**: Maintain optimal query performance\n- **Storage Cleanup**: Remove unnecessary webhook metadata\n\n**‚è∞ SCHEDULING:**\n- Typically run daily or weekly\n- Should be scheduled during low-traffic periods\n- Can be triggered manually for immediate cleanup\n- Safe to run multiple times (idempotent)\n\n**üîß SYSTEM REQUIREMENTS:**\n- Database write permissions\n- Sufficient execution time for large cleanups\n- Monitoring for cleanup success/failure\n- Logging for audit trail\n\n**üìà MONITORING:**\n- Track cleanup frequency and volume\n- Monitor for unusual cleanup patterns\n- Alert on cleanup failures\n- Performance impact assessment\n\n**üö´ SAFETY MEASURES:**\n- Only removes truly expired subscriptions\n- Preserves audit logs\n- Cannot remove active subscriptions\n- Rollback capabilities for accidental cleanup\n\n**Error Cases:**\n- **500**: Database error or cleanup process failure\n- **503**: Service temporarily unavailable during maintenance\n\n**üîê ACCESS CONTROL:**\n- Public endpoint (no authentication)\n- Rate limited to prevent abuse\n- Safe for automated system calls\n- No sensitive data exposure"
					},
					"response": []
				},
				{
					"name": "get subscriptions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üëÄ GET USER SUBSCRIPTIONS - List all watch subscriptions",
									"// Retrieve all active subscriptions for the authenticated user",
									"",
									"console.log('üëÄ Retrieving user watch subscriptions...');",
									"console.log('üìã Endpoint: GET /dedi/subscriptions');",
									"console.log('üîê Authentication: Required (Cookie or API Key)');",
									"",
									"// This endpoint will show all active subscriptions for the user",
									"console.log('üìä Fetching subscription summary...');"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ GET SUBSCRIPTIONS TESTS",
									"",
									"// Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 200', function () {",
									"    pm.expect(pm.response.code).to.equal(200);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// Test: Success Response Structure",
									"if (pm.response.code === 200) {",
									"    pm.test('‚úÖ Subscriptions retrieved successfully', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        pm.expect(responseJson.message).to.include('Successfully retrieved subscriptions');",
									"        pm.expect(responseJson).to.have.property('data');",
									"        pm.expect(responseJson.data).to.be.an('array');",
									"    });",
									"    ",
									"    const subscriptions = responseJson.data;",
									"    const activeCount = subscriptions.length;",
									"    ",
									"    pm.test(`‚úÖ User has ${activeCount} active subscriptions`, function () {",
									"        pm.expect(subscriptions).to.be.an('array');",
									"        ",
									"        // If subscriptions exist, validate structure",
									"        if (activeCount > 0) {",
									"            pm.expect(subscriptions[0]).to.have.property('id');",
									"            pm.expect(subscriptions[0]).to.have.property('type');",
									"            pm.expect(subscriptions[0]).to.have.property('webhook_url');",
									"            pm.expect(subscriptions[0]).to.have.property('is_active');",
									"            pm.expect(subscriptions[0]).to.have.property('email');",
									"        }",
									"    });",
									"    ",
									"    // Log subscription summary",
									"    console.log('üëÄ WATCH SUBSCRIPTIONS SUMMARY:');",
									"    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');",
									"    console.log('‚îÇ        Active Subscriptions        ‚îÇ');",
									"    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');",
									"    console.log(`‚îÇ Total Active:        ${activeCount.toString().padStart(8)} ‚îÇ`);",
									"    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');",
									"    ",
									"    if (activeCount > 0) {",
									"        console.log('\\nüìã SUBSCRIPTION DETAILS:');",
									"        ",
									"        subscriptions.forEach((sub, index) => {",
									"            console.log(`${index + 1}. ID: ${sub.id}`);",
									"            console.log(`   Type: ${sub.type}`);",
									"            console.log(`   Namespace: ${sub.namespace_id || 'N/A'}`);",
									"            console.log(`   Registry: ${sub.registry_name || 'N/A'}`);",
									"            console.log(`   Record: ${sub.record_name || 'N/A'}`);",
									"            console.log(`   Tag: ${sub.registry_tag || 'N/A'}`);",
									"            console.log(`   Active: ${sub.is_active}`);",
									"            console.log(`   Created: ${sub.created_at}`);",
									"            console.log(`   Webhook: ${sub.webhook_url.substring(0, 50)}...`);",
									"            console.log('   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ');",
									"        });",
									"        ",
									"        // Store first subscription ID for other tests",
									"        if (!pm.collectionVariables.get('subscription_id')) {",
									"            pm.collectionVariables.set('subscription_id', subscriptions[0].id);",
									"            console.log('üìå First subscription ID stored for future operations');",
									"        }",
									"    } else {",
									"        console.log('üì≠ No active subscriptions found');",
									"        console.log('üí° Use the subscribe endpoint to create new watch subscriptions');",
									"    }",
									"}",
									"",
									"// Test: Error Response Handling",
									"if (pm.response.code >= 400) {",
									"    pm.test('üö® Error response handled properly', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        ",
									"        if (pm.response.code === 401) {",
									"            pm.expect(responseJson.message).to.include(['unauthorized', 'authentication']);",
									"        }",
									"        ",
									"        console.log('üö® Failed to get subscriptions:', responseJson.message);",
									"    });",
									"}",
									"",
									"// Test: Response Time",
									"pm.test('‚ö° Response time is acceptable (<2s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);",
									"});",
									"",
									"// Test: Content Type",
									"pm.test('‚úÖ Response has JSON content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "Cookie",
								"value": "token={{auth_cookie}}",
								"type": "text",
								"disabled": true
							},
							{
								"key": "Authorization",
								"value": "Bearer {{api_key}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{url}}/dedi/subscriptions",
							"host": ["{{url}}"],
							"path": ["dedi", "subscriptions"]
						},
						"description": "üëÄ GET USER WATCH SUBSCRIPTIONS\n\nRetrieve all active watch subscriptions for the authenticated user.\n\n**Authentication:** Required (Cookie or API Key)\n\n**Success Response (200):**\n```json\n{\n  \"message\": \"User subscriptions retrieved successfully\",\n  \"data\": [\n    {\n      \"subscription_id\": \"sub_abc123...\",\n      \"watch_type\": \"namespace\",\n      \"target\": \"my-namespace\",\n      \"webhook_url\": \"https://your-app.com/webhook\",\n      \"events\": [\"create\", \"update\", \"delete\"],\n      \"active\": true,\n      \"created_at\": \"2024-01-01T00:00:00Z\",\n      \"expires_at\": \"2024-02-01T00:00:00Z\",\n      \"last_delivery\": \"2024-01-10T15:30:00Z\",\n      \"delivery_count\": 142,\n      \"failure_count\": 2\n    },\n    {\n      \"subscription_id\": \"sub_def456...\",\n      \"watch_type\": \"registry\",\n      \"target\": \"my-registry\",\n      \"webhook_url\": \"https://your-app.com/registry-updates\",\n      \"events\": [\"create\", \"update\"],\n      \"active\": true,\n      \"created_at\": \"2024-01-05T00:00:00Z\",\n      \"expires_at\": \"2024-02-05T00:00:00Z\",\n      \"last_delivery\": \"2024-01-14T09:15:00Z\",\n      \"delivery_count\": 67,\n      \"failure_count\": 0\n    }\n  ]\n}\n```\n\n**üìä SUBSCRIPTION DATA:**\n- **subscription_id**: Unique identifier for the subscription\n- **watch_type**: Type of resource being watched (namespace/registry/record)\n- **target**: ID of the specific resource being monitored\n- **webhook_url**: URL where notifications are delivered\n- **events**: Array of event types being monitored\n- **active**: Whether the subscription is currently active\n- **created_at**: When the subscription was created\n- **expires_at**: When the subscription will automatically expire\n- **last_delivery**: Timestamp of most recent webhook delivery\n- **delivery_count**: Total number of notifications sent\n- **failure_count**: Number of failed delivery attempts\n\n**üí° USE CASES:**\n- **Subscription Management**: View and manage all active watches\n- **Monitoring Dashboard**: Display user's notification preferences\n- **Debugging**: Check subscription status and delivery statistics\n- **Cleanup Planning**: Identify unused or problematic subscriptions\n- **Audit Trail**: Review notification history and patterns\n- **Settings UI**: Build user interface for subscription management\n\n**üìà METRICS PROVIDED:**\n- **Total Active Subscriptions**: Number of currently active watches\n- **Delivery Statistics**: Success and failure rates for each subscription\n- **Resource Distribution**: Breakdown by watch type (namespace/registry/record)\n- **Activity Timeline**: When subscriptions were created and last active\n- **Webhook Health**: Delivery success rates and failure patterns\n\n**üîç FILTERING & SORTING:**\nResponse includes all user subscriptions. For advanced filtering:\n- Client-side filtering by watch_type, target, or active status\n- Sorting by created_at, expires_at, or delivery statistics\n- Custom grouping by watch type or target resource\n\n**‚ö†Ô∏è SUBSCRIPTION STATUS:**\n- **Active**: Receiving and delivering notifications\n- **Expired**: Past expiration date, no longer delivering\n- **Failed**: Too many delivery failures, temporarily suspended\n- **Inactive**: Manually disabled by user\n\n**Error Cases:**\n- **401**: Unauthorized (invalid or missing token)\n- **500**: Database error or internal server error\n\n**üîê SECURITY:**\n- Only returns subscriptions owned by authenticated user\n- User isolation ensures data privacy\n- No sensitive webhook content exposed\n- Subscription metadata only (not webhook payloads)"
					},
					"response": []
				}
			]
		},
		{
			"name": "Platform Statistics & Analytics",
			"item": [
				{
					"name": "üìä Get Platform Statistics",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üìä Platform Statistics - Public endpoint (no authentication required)",
									"// This endpoint provides real-time platform metrics",
									"",
									"console.log('üìä Requesting platform statistics...');",
									"console.log('üåê Endpoint: GET /dedi/stats');",
									"console.log('üîì Authentication: Not required (public endpoint)');"
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"// üß™ Test: Status Code Validation",
									"pm.test('‚úÖ Status code should be 200 or 500', function () {",
									"    pm.expect(pm.response.code).to.be.oneOf([200, 500]);",
									"});",
									"",
									"const responseJson = pm.response.json();",
									"",
									"// üß™ Test: Success Response Structure",
									"if (pm.response.code === 200) {",
									"    pm.test('‚úÖ Platform statistics retrieved successfully', function () {",
									"        pm.expect(responseJson).to.have.property('totalNamespaces');",
									"        pm.expect(responseJson).to.have.property('totalRegistries');",
									"        pm.expect(responseJson).to.have.property('totalRecords');",
									"        pm.expect(responseJson).to.have.property('totalUsers');",
									"    });",
									"    ",
									"    pm.test('‚úÖ All statistics are valid numbers', function () {",
									"        pm.expect(responseJson.totalNamespaces).to.be.a('number');",
									"        pm.expect(responseJson.totalRegistries).to.be.a('number');",
									"        pm.expect(responseJson.totalRecords).to.be.a('number');",
									"        pm.expect(responseJson.totalUsers).to.be.a('number');",
									"        ",
									"        // All counts should be non-negative",
									"        pm.expect(responseJson.totalNamespaces).to.be.at.least(0);",
									"        pm.expect(responseJson.totalRegistries).to.be.at.least(0);",
									"        pm.expect(responseJson.totalRecords).to.be.at.least(0);",
									"        pm.expect(responseJson.totalUsers).to.be.at.least(0);",
									"    });",
									"    ",
									"    pm.test('‚úÖ Data consistency validation', function () {",
									"        // Records should generally be >= registries (each registry can have multiple records)",
									"        if (responseJson.totalRegistries > 0) {",
									"            pm.expect(responseJson.totalRecords).to.be.at.least(0);",
									"        }",
									"        ",
									"        // Registries should generally be >= namespaces (each namespace can have multiple registries)",
									"        if (responseJson.totalNamespaces > 0) {",
									"            pm.expect(responseJson.totalRegistries).to.be.at.least(0);",
									"        }",
									"    });",
									"    ",
									"    // üìä Log detailed statistics for monitoring",
									"    console.log('üìä PLATFORM STATISTICS OVERVIEW:');",
									"    console.log('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');",
									"    console.log('‚îÇ           DeDi Platform Stats       ‚îÇ');",
									"    console.log('‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§');",
									"    console.log(`‚îÇ üë• Total Users:      ${responseJson.totalUsers.toLocaleString().padStart(8)} ‚îÇ`);",
									"    console.log(`‚îÇ üìÅ Total Namespaces: ${responseJson.totalNamespaces.toLocaleString().padStart(8)} ‚îÇ`);",
									"    console.log(`‚îÇ üìã Total Registries: ${responseJson.totalRegistries.toLocaleString().padStart(8)} ‚îÇ`);",
									"    console.log(`‚îÇ üìÑ Total Records:    ${responseJson.totalRecords.toLocaleString().padStart(8)} ‚îÇ`);",
									"    console.log('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');",
									"    ",
									"    // Calculate ratios for insights",
									"    if (responseJson.totalNamespaces > 0) {",
									"        const registriesPerNamespace = (responseJson.totalRegistries / responseJson.totalNamespaces).toFixed(2);",
									"        console.log(`üìà Average Registries per Namespace: ${registriesPerNamespace}`);",
									"    }",
									"    ",
									"    if (responseJson.totalRegistries > 0) {",
									"        const recordsPerRegistry = (responseJson.totalRecords / responseJson.totalRegistries).toFixed(2);",
									"        console.log(`üìà Average Records per Registry: ${recordsPerRegistry}`);",
									"    }",
									"    ",
									"    if (responseJson.totalUsers > 0) {",
									"        const namespacesPerUser = (responseJson.totalNamespaces / responseJson.totalUsers).toFixed(2);",
									"        console.log(`üìà Average Namespaces per User: ${namespacesPerUser}`);",
									"    }",
									"    ",
									"    // Store stats in global variables for other requests",
									"    pm.globals.set('platform_total_users', responseJson.totalUsers);",
									"    pm.globals.set('platform_total_namespaces', responseJson.totalNamespaces);",
									"    pm.globals.set('platform_total_registries', responseJson.totalRegistries);",
									"    pm.globals.set('platform_total_records', responseJson.totalRecords);",
									"    pm.globals.set('platform_stats_updated', new Date().toISOString());",
									"}",
									"",
									"// üß™ Test: Error Response Validation",
									"if (pm.response.code === 500) {",
									"    pm.test('üö® Server Error - Database connection issue', function () {",
									"        pm.expect(responseJson).to.have.property('message');",
									"        pm.expect(responseJson.message).to.include('Failed to fetch stats');",
									"        ",
									"        if (responseJson.error) {",
									"            console.log('üö® Database Error Details:', responseJson.error);",
									"        }",
									"    });",
									"}",
									"",
									"// üß™ Test: Response Time Validation",
									"pm.test('‚ö° Response time is acceptable (<2s)', function () {",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);",
									"});",
									"",
									"// üß™ Test: Response Headers",
									"pm.test('‚úÖ Response has correct content type', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
									"});",
									"",
									"// üß™ Test: Public Endpoint (No Auth Required)",
									"pm.test('üîì Public endpoint accessible without authentication', function () {",
									"    // This endpoint should work without authentication",
									"    // If it returns 401, that indicates an unexpected auth requirement",
									"    pm.expect(pm.response.code).to.not.equal(401);",
									"});"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url}}/dedi/stats",
							"host": ["{{url}}"],
							"path": ["dedi", "stats"]
						},
						"description": "üìä GET PLATFORM STATISTICS\n\nRetrieves comprehensive real-time statistics for the entire DeDi platform, providing insights into platform usage and growth.\n\n**Authentication:** Not required (public endpoint)\n\n**Response Structure:**\n```json\n{\n  \"totalUsers\": 1250,\n  \"totalNamespaces\": 456,\n  \"totalRegistries\": 1823,\n  \"totalRecords\": 15467\n}\n```\n\n**üìä STATISTICS BREAKDOWN:**\n\n**totalUsers:** Total number of registered user accounts\n- Includes all active user profiles in the platform\n- Represents the user base size\n- Used for user growth tracking\n\n**totalNamespaces:** Total number of namespaces across all users\n- Each namespace represents a distinct organization or project\n- Indicates platform adoption by organizations\n- Measures namespace proliferation\n\n**totalRegistries:** Total number of registries across all namespaces\n- Each registry defines a schema for records\n- Shows data structure diversity\n- Indicates platform feature utilization\n\n**totalRecords:** Total number of records across all registries\n- Represents actual data entries in the platform\n- Measures platform data volume\n- Indicates active usage and content creation\n\n**üìà DERIVED METRICS:**\n- **Average Registries per Namespace:** totalRegistries √∑ totalNamespaces\n- **Average Records per Registry:** totalRecords √∑ totalRegistries\n- **Average Namespaces per User:** totalNamespaces √∑ totalUsers\n- **Platform Data Density:** totalRecords √∑ totalUsers\n\n**üí° USE CASES:**\n- **Dashboard Analytics:** Display on admin dashboards and public pages\n- **Platform Health Monitoring:** Track growth trends and usage patterns\n- **Business Intelligence:** Analyze user engagement and data creation\n- **Public Statistics:** Show platform scale to potential users\n- **API Integration:** Embed stats in external applications\n- **Monitoring Alerts:** Set up thresholds for platform monitoring\n\n**‚ö° PERFORMANCE:**\n- Optimized database queries using parallel execution\n- Fast response time (typically <500ms)\n- Cached results for high-frequency access\n- Minimal resource impact on platform\n\n**üîì ACCESS CONTROL:**\n- Public endpoint - no authentication required\n- Safe for external consumption\n- No sensitive data exposure\n- Rate limiting applied for abuse prevention\n\n**üìä MONITORING:**\n- Response time tracking\n- Data consistency validation\n- Error rate monitoring\n- Usage pattern analysis\n\n**Error Cases:**\n- **500**: Database connection error or internal server error\n\n**Integration Examples:**\n- Public website statistics widgets\n- Admin dashboard KPI displays\n- Mobile app analytics screens\n- Third-party monitoring tools\n- Business intelligence systems"
					},
					"response": []
				}
			]
		}
	],
	"variable": [
		{
			"key": "url",
			"value": "https://api.dedi.global",
			"type": "default",
			"description": "üåê DeDi API Base URL. Use 'https://api.dedi.global' for production or 'http://localhost:5200' for local development."
		},
		{
			"key": "user_email",
			"value": "testuser@yourdomain.com",
			"type": "string"
		},
		{
			"key": "user_name",
			"value": "TestUser",
			"type": "string"
		},
		{
			"key": "user_action",
			"value": "register",
			"type": "string"
		},
		{
			"key": "user_password",
			"value": "Test@123",
			"type": "string",
			"description": "üîí User password for registration/login. Must be at least 6 characters with one special character."
		},
		{
			"key": "auth_cookie",
			"value": "",
			"type": "string",
			"description": "üç™ COOKIE AUTHENTICATION: After email verification, copy the 'token' cookie from browser DevTools ‚Üí Application ‚Üí Cookies and paste it here. This will be automatically used for ALL authenticated requests in the collection! You only need to set this ONCE per session."
		},
		{
			"key": "api_key",
			"value": "",
			"type": "string",
			"description": "üîë API KEY AUTHENTICATION: Use the 'get-api-key' endpoint to generate your API key, then paste it here. This is the recommended method for production integrations. All authenticated requests will automatically use Bearer token authentication."
		},
		{
			"key": "creator_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "token",
			"value": "fetch from login",
			"type": "string"
		},
		{
			"key": "namespace",
			"value": "",
			"type": "string"
		},
		{
			"key": "namespace_name",
			"value": "",
			"type": "string"
		},
		{
			"key": "namespace_creator_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "registry_name",
			"value": "",
			"type": "string"
		},
		{
    		"key": "registry_description",
			"value": "Test registry description",
			"type": "string"
		},
		{
			"key": "registry_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "registry_auth",
			"value": "",
			"type": "string"
		},
		{
			"key": "bulk_upload_jobId",
			"value": "",
			"type": "string"
		},
		{
			"key": "current_password",
			"value": "",
			"type": "string",
			"description": "Current password for password reset"
		},
		{
			"key": "new_password",
			"value": "",
			"type": "string",
			"description": "New password for password reset"
		},
		{
			"key": "reset_token",
			"value": "",
			"type": "string",
			"description": "Password reset token received via email"
		},
		{
			"key": "refresh_token",
			"value": "",
			"type": "string",
			"description": "üîÑ Refresh token for token renewal"
		},
		{
			"key": "email_verification_token",
			"value": "",
			"type": "string",
			"description": "üìß Email verification token from magic link"
		},
		{
			"key": "delegate_email",
			"value": "",
			"type": "string",
			"description": "üë• Email address of user to add/remove as delegate"
		},
		{
			"key": "record_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "record_creator_id",
			"value": "",
			"type": "string"
		},
		{
			"key": "delegate_info",
			"value": "",
			"type": "string"
		},
		{
			"key": "record_name",
			"value": "",
			"type": "string"
		},
		{
			"key": "delegate_email",
			"value": "delegate@example.com",
			"type": "string"
		},
		{
			"key": "email_verification_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "refresh_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "rec_name",
			"value": "test-record",
			"type": "string"
		},
		{
			"key": "rec_desc",
			"value": "Test record description",
			"type": "string"
		},
		{
			"key": "namespace_desc",
			"value": "Test namespace description",
			"type": "string"
		},
		{
			"key": "ns_name_update",
			"value": "updated-namespace-name",
			"type": "string"
		},
		{
			"key": "ns_desc_update",
			"value": "Updated namespace description",
			"type": "string"
		},
		{
			"key": "reg_desc_update",
			"value": "Updated registry description",
			"type": "string"
		},
		{
			"key": "rec_desc_update",
			"value": "Updated record description",
			"type": "string"
		},
		{
			"key": "domain",
			"value": "example.com",
			"type": "string"
		},
		{
			"key": "search_query",
			"value": "",
			"type": "string"
		},
		{
			"key": "search_page",
			"value": "1",
			"type": "string"
		},
		{
			"key": "search_page_size",
			"value": "10",
			"type": "string"
		},
		{
			"key": "schema_tag",
			"value": "membership",
			"type": "string"
		},
		{
			"key": "watch_type",
			"value": "namespace",
			"type": "string",
			"description": "üëÄ Type of resource to watch: namespace, registry, or record"
		},
		{
			"key": "watch_target",
			"value": "",
			"type": "string",
			"description": "üéØ ID of the resource to watch (namespace ID, registry ID, or record ID)"
		},
		{
			"key": "webhook_url",
			"value": "https://your-app.com/webhook/dedi-updates",
			"type": "string",
			"description": "üîî Webhook URL to receive notifications"
		},
		{
			"key": "subscription_id",
			"value": "",
			"type": "string",
			"description": "üìå Watch subscription ID for unsubscribe operations"
		}
	]
}
